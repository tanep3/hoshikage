/* automatically generated by rust-bindgen 0.69.5 */
#![allow(
    non_camel_case_types,
    non_upper_case_globals,
    non_snake_case,
    dead_code
)]

pub const GGML_FILE_MAGIC: u32 = 1734831468;
pub const GGML_FILE_VERSION: u32 = 2;
pub const GGML_QNT_VERSION: u32 = 2;
pub const GGML_QNT_VERSION_FACTOR: u32 = 1000;
pub const GGML_MAX_DIMS: u32 = 4;
pub const GGML_MAX_PARAMS: u32 = 2048;
pub const GGML_MAX_SRC: u32 = 10;
pub const GGML_MAX_N_THREADS: u32 = 512;
pub const GGML_MAX_OP_PARAMS: u32 = 64;
pub const GGML_MAX_NAME: u32 = 64;
pub const GGML_DEFAULT_N_THREADS: u32 = 4;
pub const GGML_DEFAULT_GRAPH_SIZE: u32 = 2048;
pub const GGML_MEM_ALIGN: u32 = 16;
pub const GGML_EXIT_SUCCESS: u32 = 0;
pub const GGML_EXIT_ABORTED: u32 = 1;
pub const GGML_ROPE_TYPE_NORMAL: u32 = 0;
pub const GGML_ROPE_TYPE_NEOX: u32 = 2;
pub const GGML_ROPE_TYPE_MROPE: u32 = 8;
pub const GGML_ROPE_TYPE_VISION: u32 = 24;
pub const GGML_ROPE_TYPE_IMROPE: u32 = 40;
pub const GGML_MROPE_SECTIONS: u32 = 4;
pub const GGML_N_TASKS_MAX: i32 = -1;
pub const LLAMA_DEFAULT_SEED: u32 = 4294967295;
pub const LLAMA_TOKEN_NULL: i32 = -1;
pub const LLAMA_FILE_MAGIC_GGLA: u32 = 1734831201;
pub const LLAMA_FILE_MAGIC_GGSN: u32 = 1734833006;
pub const LLAMA_FILE_MAGIC_GGSQ: u32 = 1734833009;
pub const LLAMA_SESSION_MAGIC: u32 = 1734833006;
pub const LLAMA_SESSION_VERSION: u32 = 9;
pub const LLAMA_STATE_SEQ_MAGIC: u32 = 1734833009;
pub const LLAMA_STATE_SEQ_VERSION: u32 = 2;
pub const LLAMA_STATE_SEQ_FLAGS_SWA_ONLY: u32 = 1;
pub const LLAMA_STATE_SEQ_FLAGS_PARTIAL_ONLY: u32 = 1;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type ggml_abort_callback_t =
    ::std::option::Option<unsafe extern "C" fn(error_message: *const ::std::os::raw::c_char)>;
extern "C" {
    pub fn ggml_set_abort_callback(callback: ggml_abort_callback_t) -> ggml_abort_callback_t;
}
extern "C" {
    pub fn ggml_abort(
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
pub const ggml_status_GGML_STATUS_ALLOC_FAILED: ggml_status = -2;
pub const ggml_status_GGML_STATUS_FAILED: ggml_status = -1;
pub const ggml_status_GGML_STATUS_SUCCESS: ggml_status = 0;
pub const ggml_status_GGML_STATUS_ABORTED: ggml_status = 1;
pub type ggml_status = ::std::os::raw::c_int;
extern "C" {
    pub fn ggml_status_to_string(status: ggml_status) -> *const ::std::os::raw::c_char;
}
pub type ggml_fp16_t = u16;
extern "C" {
    pub fn ggml_fp16_to_fp32(arg1: ggml_fp16_t) -> f32;
}
extern "C" {
    pub fn ggml_fp32_to_fp16(arg1: f32) -> ggml_fp16_t;
}
extern "C" {
    pub fn ggml_fp16_to_fp32_row(arg1: *const ggml_fp16_t, arg2: *mut f32, arg3: i64);
}
extern "C" {
    pub fn ggml_fp32_to_fp16_row(arg1: *const f32, arg2: *mut ggml_fp16_t, arg3: i64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_bf16_t {
    pub bits: u16,
}
#[test]
fn bindgen_test_layout_ggml_bf16_t() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_bf16_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_bf16_t>(),
        2usize,
        concat!("Size of: ", stringify!(ggml_bf16_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_bf16_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ggml_bf16_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_bf16_t),
            "::",
            stringify!(bits)
        )
    );
}
extern "C" {
    pub fn ggml_fp32_to_bf16(arg1: f32) -> ggml_bf16_t;
}
extern "C" {
    pub fn ggml_bf16_to_fp32(arg1: ggml_bf16_t) -> f32;
}
extern "C" {
    pub fn ggml_bf16_to_fp32_row(arg1: *const ggml_bf16_t, arg2: *mut f32, arg3: i64);
}
extern "C" {
    pub fn ggml_fp32_to_bf16_row_ref(arg1: *const f32, arg2: *mut ggml_bf16_t, arg3: i64);
}
extern "C" {
    pub fn ggml_fp32_to_bf16_row(arg1: *const f32, arg2: *mut ggml_bf16_t, arg3: i64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_object {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_cgraph {
    _unused: [u8; 0],
}
pub const ggml_type_GGML_TYPE_F32: ggml_type = 0;
pub const ggml_type_GGML_TYPE_F16: ggml_type = 1;
pub const ggml_type_GGML_TYPE_Q4_0: ggml_type = 2;
pub const ggml_type_GGML_TYPE_Q4_1: ggml_type = 3;
pub const ggml_type_GGML_TYPE_Q5_0: ggml_type = 6;
pub const ggml_type_GGML_TYPE_Q5_1: ggml_type = 7;
pub const ggml_type_GGML_TYPE_Q8_0: ggml_type = 8;
pub const ggml_type_GGML_TYPE_Q8_1: ggml_type = 9;
pub const ggml_type_GGML_TYPE_Q2_K: ggml_type = 10;
pub const ggml_type_GGML_TYPE_Q3_K: ggml_type = 11;
pub const ggml_type_GGML_TYPE_Q4_K: ggml_type = 12;
pub const ggml_type_GGML_TYPE_Q5_K: ggml_type = 13;
pub const ggml_type_GGML_TYPE_Q6_K: ggml_type = 14;
pub const ggml_type_GGML_TYPE_Q8_K: ggml_type = 15;
pub const ggml_type_GGML_TYPE_IQ2_XXS: ggml_type = 16;
pub const ggml_type_GGML_TYPE_IQ2_XS: ggml_type = 17;
pub const ggml_type_GGML_TYPE_IQ3_XXS: ggml_type = 18;
pub const ggml_type_GGML_TYPE_IQ1_S: ggml_type = 19;
pub const ggml_type_GGML_TYPE_IQ4_NL: ggml_type = 20;
pub const ggml_type_GGML_TYPE_IQ3_S: ggml_type = 21;
pub const ggml_type_GGML_TYPE_IQ2_S: ggml_type = 22;
pub const ggml_type_GGML_TYPE_IQ4_XS: ggml_type = 23;
pub const ggml_type_GGML_TYPE_I8: ggml_type = 24;
pub const ggml_type_GGML_TYPE_I16: ggml_type = 25;
pub const ggml_type_GGML_TYPE_I32: ggml_type = 26;
pub const ggml_type_GGML_TYPE_I64: ggml_type = 27;
pub const ggml_type_GGML_TYPE_F64: ggml_type = 28;
pub const ggml_type_GGML_TYPE_IQ1_M: ggml_type = 29;
pub const ggml_type_GGML_TYPE_BF16: ggml_type = 30;
pub const ggml_type_GGML_TYPE_TQ1_0: ggml_type = 34;
pub const ggml_type_GGML_TYPE_TQ2_0: ggml_type = 35;
pub const ggml_type_GGML_TYPE_MXFP4: ggml_type = 39;
pub const ggml_type_GGML_TYPE_COUNT: ggml_type = 40;
pub type ggml_type = ::std::os::raw::c_uint;
pub const ggml_prec_GGML_PREC_DEFAULT: ggml_prec = 0;
pub const ggml_prec_GGML_PREC_F32: ggml_prec = 10;
pub type ggml_prec = ::std::os::raw::c_uint;
pub const ggml_ftype_GGML_FTYPE_UNKNOWN: ggml_ftype = -1;
pub const ggml_ftype_GGML_FTYPE_ALL_F32: ggml_ftype = 0;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_F16: ggml_ftype = 1;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_Q4_0: ggml_ftype = 2;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_Q4_1: ggml_ftype = 3;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_Q4_1_SOME_F16: ggml_ftype = 4;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_Q8_0: ggml_ftype = 7;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_Q5_0: ggml_ftype = 8;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_Q5_1: ggml_ftype = 9;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_Q2_K: ggml_ftype = 10;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_Q3_K: ggml_ftype = 11;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_Q4_K: ggml_ftype = 12;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_Q5_K: ggml_ftype = 13;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_Q6_K: ggml_ftype = 14;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_IQ2_XXS: ggml_ftype = 15;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_IQ2_XS: ggml_ftype = 16;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_IQ3_XXS: ggml_ftype = 17;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_IQ1_S: ggml_ftype = 18;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_IQ4_NL: ggml_ftype = 19;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_IQ3_S: ggml_ftype = 20;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_IQ2_S: ggml_ftype = 21;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_IQ4_XS: ggml_ftype = 22;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_IQ1_M: ggml_ftype = 23;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_BF16: ggml_ftype = 24;
pub const ggml_ftype_GGML_FTYPE_MOSTLY_MXFP4: ggml_ftype = 25;
pub type ggml_ftype = ::std::os::raw::c_int;
pub const ggml_op_GGML_OP_NONE: ggml_op = 0;
pub const ggml_op_GGML_OP_DUP: ggml_op = 1;
pub const ggml_op_GGML_OP_ADD: ggml_op = 2;
pub const ggml_op_GGML_OP_ADD_ID: ggml_op = 3;
pub const ggml_op_GGML_OP_ADD1: ggml_op = 4;
pub const ggml_op_GGML_OP_ACC: ggml_op = 5;
pub const ggml_op_GGML_OP_SUB: ggml_op = 6;
pub const ggml_op_GGML_OP_MUL: ggml_op = 7;
pub const ggml_op_GGML_OP_DIV: ggml_op = 8;
pub const ggml_op_GGML_OP_SQR: ggml_op = 9;
pub const ggml_op_GGML_OP_SQRT: ggml_op = 10;
pub const ggml_op_GGML_OP_LOG: ggml_op = 11;
pub const ggml_op_GGML_OP_SIN: ggml_op = 12;
pub const ggml_op_GGML_OP_COS: ggml_op = 13;
pub const ggml_op_GGML_OP_SUM: ggml_op = 14;
pub const ggml_op_GGML_OP_SUM_ROWS: ggml_op = 15;
pub const ggml_op_GGML_OP_CUMSUM: ggml_op = 16;
pub const ggml_op_GGML_OP_MEAN: ggml_op = 17;
pub const ggml_op_GGML_OP_ARGMAX: ggml_op = 18;
pub const ggml_op_GGML_OP_COUNT_EQUAL: ggml_op = 19;
pub const ggml_op_GGML_OP_REPEAT: ggml_op = 20;
pub const ggml_op_GGML_OP_REPEAT_BACK: ggml_op = 21;
pub const ggml_op_GGML_OP_CONCAT: ggml_op = 22;
pub const ggml_op_GGML_OP_SILU_BACK: ggml_op = 23;
pub const ggml_op_GGML_OP_NORM: ggml_op = 24;
pub const ggml_op_GGML_OP_RMS_NORM: ggml_op = 25;
pub const ggml_op_GGML_OP_RMS_NORM_BACK: ggml_op = 26;
pub const ggml_op_GGML_OP_GROUP_NORM: ggml_op = 27;
pub const ggml_op_GGML_OP_L2_NORM: ggml_op = 28;
pub const ggml_op_GGML_OP_MUL_MAT: ggml_op = 29;
pub const ggml_op_GGML_OP_MUL_MAT_ID: ggml_op = 30;
pub const ggml_op_GGML_OP_OUT_PROD: ggml_op = 31;
pub const ggml_op_GGML_OP_SCALE: ggml_op = 32;
pub const ggml_op_GGML_OP_SET: ggml_op = 33;
pub const ggml_op_GGML_OP_CPY: ggml_op = 34;
pub const ggml_op_GGML_OP_CONT: ggml_op = 35;
pub const ggml_op_GGML_OP_RESHAPE: ggml_op = 36;
pub const ggml_op_GGML_OP_VIEW: ggml_op = 37;
pub const ggml_op_GGML_OP_PERMUTE: ggml_op = 38;
pub const ggml_op_GGML_OP_TRANSPOSE: ggml_op = 39;
pub const ggml_op_GGML_OP_GET_ROWS: ggml_op = 40;
pub const ggml_op_GGML_OP_GET_ROWS_BACK: ggml_op = 41;
pub const ggml_op_GGML_OP_SET_ROWS: ggml_op = 42;
pub const ggml_op_GGML_OP_DIAG: ggml_op = 43;
pub const ggml_op_GGML_OP_DIAG_MASK_INF: ggml_op = 44;
pub const ggml_op_GGML_OP_DIAG_MASK_ZERO: ggml_op = 45;
pub const ggml_op_GGML_OP_SOFT_MAX: ggml_op = 46;
pub const ggml_op_GGML_OP_SOFT_MAX_BACK: ggml_op = 47;
pub const ggml_op_GGML_OP_ROPE: ggml_op = 48;
pub const ggml_op_GGML_OP_ROPE_BACK: ggml_op = 49;
pub const ggml_op_GGML_OP_CLAMP: ggml_op = 50;
pub const ggml_op_GGML_OP_CONV_TRANSPOSE_1D: ggml_op = 51;
pub const ggml_op_GGML_OP_IM2COL: ggml_op = 52;
pub const ggml_op_GGML_OP_IM2COL_BACK: ggml_op = 53;
pub const ggml_op_GGML_OP_IM2COL_3D: ggml_op = 54;
pub const ggml_op_GGML_OP_CONV_2D: ggml_op = 55;
pub const ggml_op_GGML_OP_CONV_3D: ggml_op = 56;
pub const ggml_op_GGML_OP_CONV_2D_DW: ggml_op = 57;
pub const ggml_op_GGML_OP_CONV_TRANSPOSE_2D: ggml_op = 58;
pub const ggml_op_GGML_OP_POOL_1D: ggml_op = 59;
pub const ggml_op_GGML_OP_POOL_2D: ggml_op = 60;
pub const ggml_op_GGML_OP_POOL_2D_BACK: ggml_op = 61;
pub const ggml_op_GGML_OP_UPSCALE: ggml_op = 62;
pub const ggml_op_GGML_OP_PAD: ggml_op = 63;
pub const ggml_op_GGML_OP_PAD_REFLECT_1D: ggml_op = 64;
pub const ggml_op_GGML_OP_ROLL: ggml_op = 65;
pub const ggml_op_GGML_OP_ARANGE: ggml_op = 66;
pub const ggml_op_GGML_OP_TIMESTEP_EMBEDDING: ggml_op = 67;
pub const ggml_op_GGML_OP_ARGSORT: ggml_op = 68;
pub const ggml_op_GGML_OP_TOP_K: ggml_op = 69;
pub const ggml_op_GGML_OP_LEAKY_RELU: ggml_op = 70;
pub const ggml_op_GGML_OP_TRI: ggml_op = 71;
pub const ggml_op_GGML_OP_FILL: ggml_op = 72;
pub const ggml_op_GGML_OP_FLASH_ATTN_EXT: ggml_op = 73;
pub const ggml_op_GGML_OP_FLASH_ATTN_BACK: ggml_op = 74;
pub const ggml_op_GGML_OP_SSM_CONV: ggml_op = 75;
pub const ggml_op_GGML_OP_SSM_SCAN: ggml_op = 76;
pub const ggml_op_GGML_OP_WIN_PART: ggml_op = 77;
pub const ggml_op_GGML_OP_WIN_UNPART: ggml_op = 78;
pub const ggml_op_GGML_OP_GET_REL_POS: ggml_op = 79;
pub const ggml_op_GGML_OP_ADD_REL_POS: ggml_op = 80;
pub const ggml_op_GGML_OP_RWKV_WKV6: ggml_op = 81;
pub const ggml_op_GGML_OP_GATED_LINEAR_ATTN: ggml_op = 82;
pub const ggml_op_GGML_OP_RWKV_WKV7: ggml_op = 83;
pub const ggml_op_GGML_OP_SOLVE_TRI: ggml_op = 84;
pub const ggml_op_GGML_OP_UNARY: ggml_op = 85;
pub const ggml_op_GGML_OP_MAP_CUSTOM1: ggml_op = 86;
pub const ggml_op_GGML_OP_MAP_CUSTOM2: ggml_op = 87;
pub const ggml_op_GGML_OP_MAP_CUSTOM3: ggml_op = 88;
pub const ggml_op_GGML_OP_CUSTOM: ggml_op = 89;
pub const ggml_op_GGML_OP_CROSS_ENTROPY_LOSS: ggml_op = 90;
pub const ggml_op_GGML_OP_CROSS_ENTROPY_LOSS_BACK: ggml_op = 91;
pub const ggml_op_GGML_OP_OPT_STEP_ADAMW: ggml_op = 92;
pub const ggml_op_GGML_OP_OPT_STEP_SGD: ggml_op = 93;
pub const ggml_op_GGML_OP_GLU: ggml_op = 94;
pub const ggml_op_GGML_OP_COUNT: ggml_op = 95;
pub type ggml_op = ::std::os::raw::c_uint;
pub const ggml_unary_op_GGML_UNARY_OP_ABS: ggml_unary_op = 0;
pub const ggml_unary_op_GGML_UNARY_OP_SGN: ggml_unary_op = 1;
pub const ggml_unary_op_GGML_UNARY_OP_NEG: ggml_unary_op = 2;
pub const ggml_unary_op_GGML_UNARY_OP_STEP: ggml_unary_op = 3;
pub const ggml_unary_op_GGML_UNARY_OP_TANH: ggml_unary_op = 4;
pub const ggml_unary_op_GGML_UNARY_OP_ELU: ggml_unary_op = 5;
pub const ggml_unary_op_GGML_UNARY_OP_RELU: ggml_unary_op = 6;
pub const ggml_unary_op_GGML_UNARY_OP_SIGMOID: ggml_unary_op = 7;
pub const ggml_unary_op_GGML_UNARY_OP_GELU: ggml_unary_op = 8;
pub const ggml_unary_op_GGML_UNARY_OP_GELU_QUICK: ggml_unary_op = 9;
pub const ggml_unary_op_GGML_UNARY_OP_SILU: ggml_unary_op = 10;
pub const ggml_unary_op_GGML_UNARY_OP_HARDSWISH: ggml_unary_op = 11;
pub const ggml_unary_op_GGML_UNARY_OP_HARDSIGMOID: ggml_unary_op = 12;
pub const ggml_unary_op_GGML_UNARY_OP_EXP: ggml_unary_op = 13;
pub const ggml_unary_op_GGML_UNARY_OP_EXPM1: ggml_unary_op = 14;
pub const ggml_unary_op_GGML_UNARY_OP_SOFTPLUS: ggml_unary_op = 15;
pub const ggml_unary_op_GGML_UNARY_OP_GELU_ERF: ggml_unary_op = 16;
pub const ggml_unary_op_GGML_UNARY_OP_XIELU: ggml_unary_op = 17;
pub const ggml_unary_op_GGML_UNARY_OP_FLOOR: ggml_unary_op = 18;
pub const ggml_unary_op_GGML_UNARY_OP_CEIL: ggml_unary_op = 19;
pub const ggml_unary_op_GGML_UNARY_OP_ROUND: ggml_unary_op = 20;
pub const ggml_unary_op_GGML_UNARY_OP_TRUNC: ggml_unary_op = 21;
pub const ggml_unary_op_GGML_UNARY_OP_COUNT: ggml_unary_op = 22;
pub type ggml_unary_op = ::std::os::raw::c_uint;
pub const ggml_glu_op_GGML_GLU_OP_REGLU: ggml_glu_op = 0;
pub const ggml_glu_op_GGML_GLU_OP_GEGLU: ggml_glu_op = 1;
pub const ggml_glu_op_GGML_GLU_OP_SWIGLU: ggml_glu_op = 2;
pub const ggml_glu_op_GGML_GLU_OP_SWIGLU_OAI: ggml_glu_op = 3;
pub const ggml_glu_op_GGML_GLU_OP_GEGLU_ERF: ggml_glu_op = 4;
pub const ggml_glu_op_GGML_GLU_OP_GEGLU_QUICK: ggml_glu_op = 5;
pub const ggml_glu_op_GGML_GLU_OP_COUNT: ggml_glu_op = 6;
pub type ggml_glu_op = ::std::os::raw::c_uint;
pub const ggml_object_type_GGML_OBJECT_TYPE_TENSOR: ggml_object_type = 0;
pub const ggml_object_type_GGML_OBJECT_TYPE_GRAPH: ggml_object_type = 1;
pub const ggml_object_type_GGML_OBJECT_TYPE_WORK_BUFFER: ggml_object_type = 2;
pub type ggml_object_type = ::std::os::raw::c_uint;
pub const ggml_log_level_GGML_LOG_LEVEL_NONE: ggml_log_level = 0;
pub const ggml_log_level_GGML_LOG_LEVEL_DEBUG: ggml_log_level = 1;
pub const ggml_log_level_GGML_LOG_LEVEL_INFO: ggml_log_level = 2;
pub const ggml_log_level_GGML_LOG_LEVEL_WARN: ggml_log_level = 3;
pub const ggml_log_level_GGML_LOG_LEVEL_ERROR: ggml_log_level = 4;
pub const ggml_log_level_GGML_LOG_LEVEL_CONT: ggml_log_level = 5;
pub type ggml_log_level = ::std::os::raw::c_uint;
pub const ggml_tensor_flag_GGML_TENSOR_FLAG_INPUT: ggml_tensor_flag = 1;
pub const ggml_tensor_flag_GGML_TENSOR_FLAG_OUTPUT: ggml_tensor_flag = 2;
pub const ggml_tensor_flag_GGML_TENSOR_FLAG_PARAM: ggml_tensor_flag = 4;
pub const ggml_tensor_flag_GGML_TENSOR_FLAG_LOSS: ggml_tensor_flag = 8;
pub type ggml_tensor_flag = ::std::os::raw::c_uint;
pub const ggml_tri_type_GGML_TRI_TYPE_UPPER_DIAG: ggml_tri_type = 0;
pub const ggml_tri_type_GGML_TRI_TYPE_UPPER: ggml_tri_type = 1;
pub const ggml_tri_type_GGML_TRI_TYPE_LOWER_DIAG: ggml_tri_type = 2;
pub const ggml_tri_type_GGML_TRI_TYPE_LOWER: ggml_tri_type = 3;
pub type ggml_tri_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_init_params {
    pub mem_size: usize,
    pub mem_buffer: *mut ::std::os::raw::c_void,
    pub no_alloc: bool,
}
#[test]
fn bindgen_test_layout_ggml_init_params() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_init_params> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_init_params>(),
        24usize,
        concat!("Size of: ", stringify!(ggml_init_params))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_init_params>(),
        8usize,
        concat!("Alignment of ", stringify!(ggml_init_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_init_params),
            "::",
            stringify!(mem_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_init_params),
            "::",
            stringify!(mem_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no_alloc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_init_params),
            "::",
            stringify!(no_alloc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_tensor {
    pub type_: ggml_type,
    pub buffer: *mut ggml_backend_buffer,
    pub ne: [i64; 4usize],
    pub nb: [usize; 4usize],
    pub op: ggml_op,
    pub op_params: [i32; 16usize],
    pub flags: i32,
    pub src: [*mut ggml_tensor; 10usize],
    pub view_src: *mut ggml_tensor,
    pub view_offs: usize,
    pub data: *mut ::std::os::raw::c_void,
    pub name: [::std::os::raw::c_char; 64usize],
    pub extra: *mut ::std::os::raw::c_void,
    pub padding: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_ggml_tensor() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_tensor> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_tensor>(),
        336usize,
        concat!("Size of: ", stringify!(ggml_tensor))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_tensor>(),
        8usize,
        concat!("Alignment of ", stringify!(ggml_tensor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(ne)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(nb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).op) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).op_params) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(op_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).view_src) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(view_src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).view_offs) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(view_offs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extra) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(extra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tensor),
            "::",
            stringify!(padding)
        )
    );
}
pub const GGML_TENSOR_SIZE: usize = 336;
pub type ggml_abort_callback =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>;
pub type ggml_guid = [u8; 16usize];
pub type ggml_guid_t = *mut ggml_guid;
extern "C" {
    pub fn ggml_guid_matches(guid_a: ggml_guid_t, guid_b: ggml_guid_t) -> bool;
}
extern "C" {
    pub fn ggml_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_commit() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_time_init();
}
extern "C" {
    pub fn ggml_time_ms() -> i64;
}
extern "C" {
    pub fn ggml_time_us() -> i64;
}
extern "C" {
    pub fn ggml_cycles() -> i64;
}
extern "C" {
    pub fn ggml_cycles_per_ms() -> i64;
}
extern "C" {
    pub fn ggml_fopen(
        fname: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ggml_print_object(obj: *const ggml_object);
}
extern "C" {
    pub fn ggml_print_objects(ctx: *const ggml_context);
}
extern "C" {
    pub fn ggml_nelements(tensor: *const ggml_tensor) -> i64;
}
extern "C" {
    pub fn ggml_nrows(tensor: *const ggml_tensor) -> i64;
}
extern "C" {
    pub fn ggml_nbytes(tensor: *const ggml_tensor) -> usize;
}
extern "C" {
    pub fn ggml_nbytes_pad(tensor: *const ggml_tensor) -> usize;
}
extern "C" {
    pub fn ggml_blck_size(type_: ggml_type) -> i64;
}
extern "C" {
    pub fn ggml_type_size(type_: ggml_type) -> usize;
}
extern "C" {
    pub fn ggml_row_size(type_: ggml_type, ne: i64) -> usize;
}
extern "C" {
    pub fn ggml_type_sizef(type_: ggml_type) -> f64;
}
extern "C" {
    pub fn ggml_type_name(type_: ggml_type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_op_name(op: ggml_op) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_op_symbol(op: ggml_op) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_unary_op_name(op: ggml_unary_op) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_glu_op_name(op: ggml_glu_op) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_op_desc(t: *const ggml_tensor) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_element_size(tensor: *const ggml_tensor) -> usize;
}
extern "C" {
    pub fn ggml_is_quantized(type_: ggml_type) -> bool;
}
extern "C" {
    pub fn ggml_ftype_to_ggml_type(ftype: ggml_ftype) -> ggml_type;
}
extern "C" {
    pub fn ggml_is_transposed(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_is_permuted(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_is_empty(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_is_scalar(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_is_vector(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_is_matrix(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_is_3d(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_n_dims(tensor: *const ggml_tensor) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_is_contiguous(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_is_contiguous_0(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_is_contiguous_1(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_is_contiguous_2(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_is_contiguously_allocated(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_is_contiguous_channels(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_is_contiguous_rows(tensor: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_are_same_shape(t0: *const ggml_tensor, t1: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_are_same_stride(t0: *const ggml_tensor, t1: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_can_repeat(t0: *const ggml_tensor, t1: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_tensor_overhead() -> usize;
}
extern "C" {
    pub fn ggml_validate_row_data(
        type_: ggml_type,
        data: *const ::std::os::raw::c_void,
        nbytes: usize,
    ) -> bool;
}
extern "C" {
    pub fn ggml_init(params: ggml_init_params) -> *mut ggml_context;
}
extern "C" {
    pub fn ggml_reset(ctx: *mut ggml_context);
}
extern "C" {
    pub fn ggml_free(ctx: *mut ggml_context);
}
extern "C" {
    pub fn ggml_used_mem(ctx: *const ggml_context) -> usize;
}
extern "C" {
    pub fn ggml_get_no_alloc(ctx: *mut ggml_context) -> bool;
}
extern "C" {
    pub fn ggml_set_no_alloc(ctx: *mut ggml_context, no_alloc: bool);
}
extern "C" {
    pub fn ggml_get_mem_buffer(ctx: *const ggml_context) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ggml_get_mem_size(ctx: *const ggml_context) -> usize;
}
extern "C" {
    pub fn ggml_get_max_tensor_size(ctx: *const ggml_context) -> usize;
}
extern "C" {
    pub fn ggml_new_tensor(
        ctx: *mut ggml_context,
        type_: ggml_type,
        n_dims: ::std::os::raw::c_int,
        ne: *const i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_new_tensor_1d(
        ctx: *mut ggml_context,
        type_: ggml_type,
        ne0: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_new_tensor_2d(
        ctx: *mut ggml_context,
        type_: ggml_type,
        ne0: i64,
        ne1: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_new_tensor_3d(
        ctx: *mut ggml_context,
        type_: ggml_type,
        ne0: i64,
        ne1: i64,
        ne2: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_new_tensor_4d(
        ctx: *mut ggml_context,
        type_: ggml_type,
        ne0: i64,
        ne1: i64,
        ne2: i64,
        ne3: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_new_buffer(ctx: *mut ggml_context, nbytes: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ggml_dup_tensor(ctx: *mut ggml_context, src: *const ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_view_tensor(ctx: *mut ggml_context, src: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_get_first_tensor(ctx: *const ggml_context) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_get_next_tensor(
        ctx: *const ggml_context,
        tensor: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_get_tensor(
        ctx: *mut ggml_context,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_unravel_index(
        tensor: *const ggml_tensor,
        i: i64,
        i0: *mut i64,
        i1: *mut i64,
        i2: *mut i64,
        i3: *mut i64,
    );
}
extern "C" {
    pub fn ggml_get_unary_op(tensor: *const ggml_tensor) -> ggml_unary_op;
}
extern "C" {
    pub fn ggml_get_glu_op(tensor: *const ggml_tensor) -> ggml_glu_op;
}
extern "C" {
    pub fn ggml_get_data(tensor: *const ggml_tensor) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ggml_get_data_f32(tensor: *const ggml_tensor) -> *mut f32;
}
extern "C" {
    pub fn ggml_get_name(tensor: *const ggml_tensor) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_set_name(
        tensor: *mut ggml_tensor,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_format_name(
        tensor: *mut ggml_tensor,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_set_input(tensor: *mut ggml_tensor);
}
extern "C" {
    pub fn ggml_set_output(tensor: *mut ggml_tensor);
}
extern "C" {
    pub fn ggml_set_param(tensor: *mut ggml_tensor);
}
extern "C" {
    pub fn ggml_set_loss(tensor: *mut ggml_tensor);
}
extern "C" {
    pub fn ggml_dup(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_dup_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_add(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_add_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_add_cast(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        type_: ggml_type,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_add_id(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        ids: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_add1(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_add1_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_acc(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        nb1: usize,
        nb2: usize,
        nb3: usize,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_acc_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        nb1: usize,
        nb2: usize,
        nb3: usize,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sub(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sub_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_mul(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_mul_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_div(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_div_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sqr(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sqr_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sqrt(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sqrt_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_log(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_log_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_expm1(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_expm1_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_softplus(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_softplus_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sin(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sin_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cos(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cos_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sum(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sum_rows(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cumsum(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_mean(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_argmax(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_count_equal(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_repeat(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_repeat_4d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
        ne1: i64,
        ne2: i64,
        ne3: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_repeat_back(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_concat(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        dim: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_abs(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_abs_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sgn(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sgn_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_neg(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_neg_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_step(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_step_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_tanh(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_tanh_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_elu(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_elu_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_relu(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_leaky_relu(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        negative_slope: f32,
        inplace: bool,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_relu_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sigmoid(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_sigmoid_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_gelu(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_gelu_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_gelu_erf(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_gelu_erf_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_gelu_quick(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_gelu_quick_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor)
        -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_silu(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_silu_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_silu_back(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_hardswish(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_hardsigmoid(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_exp(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_exp_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_floor(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_floor_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_ceil(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_ceil_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_round(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_round_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    #[doc = " Truncates the fractional part of each element in the tensor (towards zero).\n For example: trunc(3.7) = 3.0, trunc(-2.9) = -2.0\n Similar to std::trunc in C/C++."]
    pub fn ggml_trunc(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_trunc_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_xielu(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        alpha_n: f32,
        alpha_p: f32,
        beta: f32,
        eps: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_glu(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        op: ggml_glu_op,
        swapped: bool,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_reglu(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_reglu_swapped(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_geglu(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_geglu_swapped(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_swiglu(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_swiglu_swapped(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_geglu_erf(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_geglu_erf_swapped(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_geglu_quick(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_geglu_quick_swapped(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_glu_split(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        op: ggml_glu_op,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_reglu_split(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_geglu_split(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_swiglu_split(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_geglu_erf_split(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_geglu_quick_split(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_swiglu_oai(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        alpha: f32,
        limit: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_norm(ctx: *mut ggml_context, a: *mut ggml_tensor, eps: f32) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_norm_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        eps: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rms_norm(ctx: *mut ggml_context, a: *mut ggml_tensor, eps: f32)
        -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rms_norm_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        eps: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_group_norm(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        n_groups: ::std::os::raw::c_int,
        eps: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_group_norm_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        n_groups: ::std::os::raw::c_int,
        eps: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_l2_norm(ctx: *mut ggml_context, a: *mut ggml_tensor, eps: f32) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_l2_norm_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        eps: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rms_norm_back(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        eps: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_mul_mat(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_mul_mat_set_prec(a: *mut ggml_tensor, prec: ggml_prec);
}
extern "C" {
    pub fn ggml_mul_mat_id(
        ctx: *mut ggml_context,
        as_: *mut ggml_tensor,
        b: *mut ggml_tensor,
        ids: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_out_prod(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_scale(ctx: *mut ggml_context, a: *mut ggml_tensor, s: f32) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_scale_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        s: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_scale_bias(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        s: f32,
        b: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_scale_bias_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        s: f32,
        b: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_set(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        nb1: usize,
        nb2: usize,
        nb3: usize,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_set_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        nb1: usize,
        nb2: usize,
        nb3: usize,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_set_1d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_set_1d_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_set_2d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        nb1: usize,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_set_2d_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        nb1: usize,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cpy(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cast(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        type_: ggml_type,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cont(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cont_1d(ctx: *mut ggml_context, a: *mut ggml_tensor, ne0: i64) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cont_2d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
        ne1: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cont_3d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
        ne1: i64,
        ne2: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cont_4d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
        ne1: i64,
        ne2: i64,
        ne3: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_reshape(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_reshape_1d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_reshape_2d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
        ne1: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_reshape_3d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
        ne1: i64,
        ne2: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_reshape_4d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
        ne1: i64,
        ne2: i64,
        ne3: i64,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_view_1d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_view_2d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
        ne1: i64,
        nb1: usize,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_view_3d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
        ne1: i64,
        ne2: i64,
        nb1: usize,
        nb2: usize,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_view_4d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
        ne1: i64,
        ne2: i64,
        ne3: i64,
        nb1: usize,
        nb2: usize,
        nb3: usize,
        offset: usize,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_permute(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        axis0: ::std::os::raw::c_int,
        axis1: ::std::os::raw::c_int,
        axis2: ::std::os::raw::c_int,
        axis3: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_transpose(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_get_rows(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_get_rows_back(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        c: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_set_rows(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        c: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_diag(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_diag_mask_inf(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        n_past: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_diag_mask_inf_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        n_past: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_diag_mask_zero(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        n_past: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_diag_mask_zero_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        n_past: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_soft_max(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_soft_max_inplace(ctx: *mut ggml_context, a: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_soft_max_ext(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        mask: *mut ggml_tensor,
        scale: f32,
        max_bias: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_soft_max_ext_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        mask: *mut ggml_tensor,
        scale: f32,
        max_bias: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_soft_max_add_sinks(a: *mut ggml_tensor, sinks: *mut ggml_tensor);
}
extern "C" {
    pub fn ggml_soft_max_ext_back(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        scale: f32,
        max_bias: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_soft_max_ext_back_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        scale: f32,
        max_bias: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rope(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        n_dims: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rope_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        n_dims: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rope_ext(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        c: *mut ggml_tensor,
        n_dims: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
        n_ctx_orig: ::std::os::raw::c_int,
        freq_base: f32,
        freq_scale: f32,
        ext_factor: f32,
        attn_factor: f32,
        beta_fast: f32,
        beta_slow: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rope_multi(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        c: *mut ggml_tensor,
        n_dims: ::std::os::raw::c_int,
        sections: *mut ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
        n_ctx_orig: ::std::os::raw::c_int,
        freq_base: f32,
        freq_scale: f32,
        ext_factor: f32,
        attn_factor: f32,
        beta_fast: f32,
        beta_slow: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rope_ext_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        c: *mut ggml_tensor,
        n_dims: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
        n_ctx_orig: ::std::os::raw::c_int,
        freq_base: f32,
        freq_scale: f32,
        ext_factor: f32,
        attn_factor: f32,
        beta_fast: f32,
        beta_slow: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rope_multi_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        c: *mut ggml_tensor,
        n_dims: ::std::os::raw::c_int,
        sections: *mut ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
        n_ctx_orig: ::std::os::raw::c_int,
        freq_base: f32,
        freq_scale: f32,
        ext_factor: f32,
        attn_factor: f32,
        beta_fast: f32,
        beta_slow: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rope_custom(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        n_dims: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
        n_ctx_orig: ::std::os::raw::c_int,
        freq_base: f32,
        freq_scale: f32,
        ext_factor: f32,
        attn_factor: f32,
        beta_fast: f32,
        beta_slow: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rope_custom_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        n_dims: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
        n_ctx_orig: ::std::os::raw::c_int,
        freq_base: f32,
        freq_scale: f32,
        ext_factor: f32,
        attn_factor: f32,
        beta_fast: f32,
        beta_slow: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rope_yarn_corr_dims(
        n_dims: ::std::os::raw::c_int,
        n_ctx_orig: ::std::os::raw::c_int,
        freq_base: f32,
        beta_fast: f32,
        beta_slow: f32,
        dims: *mut f32,
    );
}
extern "C" {
    pub fn ggml_rope_ext_back(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        c: *mut ggml_tensor,
        n_dims: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
        n_ctx_orig: ::std::os::raw::c_int,
        freq_base: f32,
        freq_scale: f32,
        ext_factor: f32,
        attn_factor: f32,
        beta_fast: f32,
        beta_slow: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rope_multi_back(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        c: *mut ggml_tensor,
        n_dims: ::std::os::raw::c_int,
        sections: *mut ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
        n_ctx_orig: ::std::os::raw::c_int,
        freq_base: f32,
        freq_scale: f32,
        ext_factor: f32,
        attn_factor: f32,
        beta_fast: f32,
        beta_slow: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_clamp(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        min: f32,
        max: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_im2col(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        s0: ::std::os::raw::c_int,
        s1: ::std::os::raw::c_int,
        p0: ::std::os::raw::c_int,
        p1: ::std::os::raw::c_int,
        d0: ::std::os::raw::c_int,
        d1: ::std::os::raw::c_int,
        is_2D: bool,
        dst_type: ggml_type,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_im2col_back(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        ne: *mut i64,
        s0: ::std::os::raw::c_int,
        s1: ::std::os::raw::c_int,
        p0: ::std::os::raw::c_int,
        p1: ::std::os::raw::c_int,
        d0: ::std::os::raw::c_int,
        d1: ::std::os::raw::c_int,
        is_2D: bool,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_1d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        s0: ::std::os::raw::c_int,
        p0: ::std::os::raw::c_int,
        d0: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_1d_ph(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        s: ::std::os::raw::c_int,
        d: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_1d_dw(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        s0: ::std::os::raw::c_int,
        p0: ::std::os::raw::c_int,
        d0: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_1d_dw_ph(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        s0: ::std::os::raw::c_int,
        d0: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_transpose_1d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        s0: ::std::os::raw::c_int,
        p0: ::std::os::raw::c_int,
        d0: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_2d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        s0: ::std::os::raw::c_int,
        s1: ::std::os::raw::c_int,
        p0: ::std::os::raw::c_int,
        p1: ::std::os::raw::c_int,
        d0: ::std::os::raw::c_int,
        d1: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_im2col_3d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        IC: i64,
        s0: ::std::os::raw::c_int,
        s1: ::std::os::raw::c_int,
        s2: ::std::os::raw::c_int,
        p0: ::std::os::raw::c_int,
        p1: ::std::os::raw::c_int,
        p2: ::std::os::raw::c_int,
        d0: ::std::os::raw::c_int,
        d1: ::std::os::raw::c_int,
        d2: ::std::os::raw::c_int,
        dst_type: ggml_type,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_3d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        IC: i64,
        s0: ::std::os::raw::c_int,
        s1: ::std::os::raw::c_int,
        s2: ::std::os::raw::c_int,
        p0: ::std::os::raw::c_int,
        p1: ::std::os::raw::c_int,
        p2: ::std::os::raw::c_int,
        d0: ::std::os::raw::c_int,
        d1: ::std::os::raw::c_int,
        d2: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_2d_sk_p0(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_2d_s1_ph(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_2d_dw(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        s0: ::std::os::raw::c_int,
        s1: ::std::os::raw::c_int,
        p0: ::std::os::raw::c_int,
        p1: ::std::os::raw::c_int,
        d0: ::std::os::raw::c_int,
        d1: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_2d_dw_direct(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        stride0: ::std::os::raw::c_int,
        stride1: ::std::os::raw::c_int,
        pad0: ::std::os::raw::c_int,
        pad1: ::std::os::raw::c_int,
        dilation0: ::std::os::raw::c_int,
        dilation1: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_transpose_2d_p0(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        stride: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_2d_direct(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        s0: ::std::os::raw::c_int,
        s1: ::std::os::raw::c_int,
        p0: ::std::os::raw::c_int,
        p1: ::std::os::raw::c_int,
        d0: ::std::os::raw::c_int,
        d1: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_conv_3d_direct(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        s0: ::std::os::raw::c_int,
        s1: ::std::os::raw::c_int,
        s2: ::std::os::raw::c_int,
        p0: ::std::os::raw::c_int,
        p1: ::std::os::raw::c_int,
        p2: ::std::os::raw::c_int,
        d0: ::std::os::raw::c_int,
        d1: ::std::os::raw::c_int,
        d2: ::std::os::raw::c_int,
        n_channels: ::std::os::raw::c_int,
        n_batch: ::std::os::raw::c_int,
        n_channels_out: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
pub const ggml_op_pool_GGML_OP_POOL_MAX: ggml_op_pool = 0;
pub const ggml_op_pool_GGML_OP_POOL_AVG: ggml_op_pool = 1;
pub const ggml_op_pool_GGML_OP_POOL_COUNT: ggml_op_pool = 2;
pub type ggml_op_pool = ::std::os::raw::c_uint;
extern "C" {
    pub fn ggml_pool_1d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        op: ggml_op_pool,
        k0: ::std::os::raw::c_int,
        s0: ::std::os::raw::c_int,
        p0: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_pool_2d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        op: ggml_op_pool,
        k0: ::std::os::raw::c_int,
        k1: ::std::os::raw::c_int,
        s0: ::std::os::raw::c_int,
        s1: ::std::os::raw::c_int,
        p0: f32,
        p1: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_pool_2d_back(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        af: *mut ggml_tensor,
        op: ggml_op_pool,
        k0: ::std::os::raw::c_int,
        k1: ::std::os::raw::c_int,
        s0: ::std::os::raw::c_int,
        s1: ::std::os::raw::c_int,
        p0: f32,
        p1: f32,
    ) -> *mut ggml_tensor;
}
pub const ggml_scale_mode_GGML_SCALE_MODE_NEAREST: ggml_scale_mode = 0;
pub const ggml_scale_mode_GGML_SCALE_MODE_BILINEAR: ggml_scale_mode = 1;
pub const ggml_scale_mode_GGML_SCALE_MODE_BICUBIC: ggml_scale_mode = 2;
pub const ggml_scale_mode_GGML_SCALE_MODE_COUNT: ggml_scale_mode = 3;
pub type ggml_scale_mode = ::std::os::raw::c_uint;
pub const ggml_scale_flag_GGML_SCALE_FLAG_ALIGN_CORNERS: ggml_scale_flag = 256;
pub const ggml_scale_flag_GGML_SCALE_FLAG_ANTIALIAS: ggml_scale_flag = 512;
pub type ggml_scale_flag = ::std::os::raw::c_uint;
extern "C" {
    pub fn ggml_upscale(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        scale_factor: ::std::os::raw::c_int,
        mode: ggml_scale_mode,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_upscale_ext(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: ::std::os::raw::c_int,
        ne1: ::std::os::raw::c_int,
        ne2: ::std::os::raw::c_int,
        ne3: ::std::os::raw::c_int,
        mode: ggml_scale_mode,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_interpolate(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        ne0: i64,
        ne1: i64,
        ne2: i64,
        ne3: i64,
        mode: u32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_pad(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        p0: ::std::os::raw::c_int,
        p1: ::std::os::raw::c_int,
        p2: ::std::os::raw::c_int,
        p3: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_pad_circular(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        p0: ::std::os::raw::c_int,
        p1: ::std::os::raw::c_int,
        p2: ::std::os::raw::c_int,
        p3: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_pad_ext(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        lp0: ::std::os::raw::c_int,
        rp0: ::std::os::raw::c_int,
        lp1: ::std::os::raw::c_int,
        rp1: ::std::os::raw::c_int,
        lp2: ::std::os::raw::c_int,
        rp2: ::std::os::raw::c_int,
        lp3: ::std::os::raw::c_int,
        rp3: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_pad_ext_circular(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        lp0: ::std::os::raw::c_int,
        rp0: ::std::os::raw::c_int,
        lp1: ::std::os::raw::c_int,
        rp1: ::std::os::raw::c_int,
        lp2: ::std::os::raw::c_int,
        rp2: ::std::os::raw::c_int,
        lp3: ::std::os::raw::c_int,
        rp3: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_pad_reflect_1d(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        p0: ::std::os::raw::c_int,
        p1: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_roll(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        shift0: ::std::os::raw::c_int,
        shift1: ::std::os::raw::c_int,
        shift2: ::std::os::raw::c_int,
        shift3: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_tri(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        type_: ggml_tri_type,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_fill(ctx: *mut ggml_context, a: *mut ggml_tensor, c: f32) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_fill_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        c: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_timestep_embedding(
        ctx: *mut ggml_context,
        timesteps: *mut ggml_tensor,
        dim: ::std::os::raw::c_int,
        max_period: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
pub const ggml_sort_order_GGML_SORT_ORDER_ASC: ggml_sort_order = 0;
pub const ggml_sort_order_GGML_SORT_ORDER_DESC: ggml_sort_order = 1;
pub type ggml_sort_order = ::std::os::raw::c_uint;
extern "C" {
    pub fn ggml_argsort(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        order: ggml_sort_order,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_argsort_top_k(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        k: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_top_k(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        k: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_arange(
        ctx: *mut ggml_context,
        start: f32,
        stop: f32,
        step: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_flash_attn_ext(
        ctx: *mut ggml_context,
        q: *mut ggml_tensor,
        k: *mut ggml_tensor,
        v: *mut ggml_tensor,
        mask: *mut ggml_tensor,
        scale: f32,
        max_bias: f32,
        logit_softcap: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_flash_attn_ext_set_prec(a: *mut ggml_tensor, prec: ggml_prec);
}
extern "C" {
    pub fn ggml_flash_attn_ext_get_prec(a: *const ggml_tensor) -> ggml_prec;
}
extern "C" {
    pub fn ggml_flash_attn_ext_add_sinks(a: *mut ggml_tensor, sinks: *mut ggml_tensor);
}
extern "C" {
    pub fn ggml_flash_attn_back(
        ctx: *mut ggml_context,
        q: *mut ggml_tensor,
        k: *mut ggml_tensor,
        v: *mut ggml_tensor,
        d: *mut ggml_tensor,
        masked: bool,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_ssm_conv(
        ctx: *mut ggml_context,
        sx: *mut ggml_tensor,
        c: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_ssm_scan(
        ctx: *mut ggml_context,
        s: *mut ggml_tensor,
        x: *mut ggml_tensor,
        dt: *mut ggml_tensor,
        A: *mut ggml_tensor,
        B: *mut ggml_tensor,
        C: *mut ggml_tensor,
        ids: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_win_part(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        w: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_win_unpart(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        w0: ::std::os::raw::c_int,
        h0: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_unary(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        op: ggml_unary_op,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_unary_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        op: ggml_unary_op,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_get_rel_pos(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        qh: ::std::os::raw::c_int,
        kh: ::std::os::raw::c_int,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_add_rel_pos(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        pw: *mut ggml_tensor,
        ph: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_add_rel_pos_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        pw: *mut ggml_tensor,
        ph: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rwkv_wkv6(
        ctx: *mut ggml_context,
        k: *mut ggml_tensor,
        v: *mut ggml_tensor,
        r: *mut ggml_tensor,
        tf: *mut ggml_tensor,
        td: *mut ggml_tensor,
        state: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_gated_linear_attn(
        ctx: *mut ggml_context,
        k: *mut ggml_tensor,
        v: *mut ggml_tensor,
        q: *mut ggml_tensor,
        g: *mut ggml_tensor,
        state: *mut ggml_tensor,
        scale: f32,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_rwkv_wkv7(
        ctx: *mut ggml_context,
        r: *mut ggml_tensor,
        w: *mut ggml_tensor,
        k: *mut ggml_tensor,
        v: *mut ggml_tensor,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        state: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_solve_tri(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        left: bool,
        lower: bool,
        uni: bool,
    ) -> *mut ggml_tensor;
}
pub type ggml_custom1_op_t = ::std::option::Option<
    unsafe extern "C" fn(
        dst: *mut ggml_tensor,
        a: *const ggml_tensor,
        ith: ::std::os::raw::c_int,
        nth: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ),
>;
pub type ggml_custom2_op_t = ::std::option::Option<
    unsafe extern "C" fn(
        dst: *mut ggml_tensor,
        a: *const ggml_tensor,
        b: *const ggml_tensor,
        ith: ::std::os::raw::c_int,
        nth: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ),
>;
pub type ggml_custom3_op_t = ::std::option::Option<
    unsafe extern "C" fn(
        dst: *mut ggml_tensor,
        a: *const ggml_tensor,
        b: *const ggml_tensor,
        c: *const ggml_tensor,
        ith: ::std::os::raw::c_int,
        nth: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn ggml_map_custom1(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        fun: ggml_custom1_op_t,
        n_tasks: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_map_custom1_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        fun: ggml_custom1_op_t,
        n_tasks: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_map_custom2(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        fun: ggml_custom2_op_t,
        n_tasks: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_map_custom2_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        fun: ggml_custom2_op_t,
        n_tasks: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_map_custom3(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        c: *mut ggml_tensor,
        fun: ggml_custom3_op_t,
        n_tasks: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_map_custom3_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        c: *mut ggml_tensor,
        fun: ggml_custom3_op_t,
        n_tasks: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> *mut ggml_tensor;
}
pub type ggml_custom_op_t = ::std::option::Option<
    unsafe extern "C" fn(
        dst: *mut ggml_tensor,
        ith: ::std::os::raw::c_int,
        nth: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn ggml_custom_4d(
        ctx: *mut ggml_context,
        type_: ggml_type,
        ne0: i64,
        ne1: i64,
        ne2: i64,
        ne3: i64,
        args: *mut *mut ggml_tensor,
        n_args: ::std::os::raw::c_int,
        fun: ggml_custom_op_t,
        n_tasks: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_custom_inplace(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        args: *mut *mut ggml_tensor,
        n_args: ::std::os::raw::c_int,
        fun: ggml_custom_op_t,
        n_tasks: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cross_entropy_loss(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_cross_entropy_loss_back(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        b: *mut ggml_tensor,
        c: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_opt_step_adamw(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        grad: *mut ggml_tensor,
        m: *mut ggml_tensor,
        v: *mut ggml_tensor,
        adamw_params: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_opt_step_sgd(
        ctx: *mut ggml_context,
        a: *mut ggml_tensor,
        grad: *mut ggml_tensor,
        sgd_params: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_build_forward_expand(cgraph: *mut ggml_cgraph, tensor: *mut ggml_tensor);
}
extern "C" {
    pub fn ggml_build_backward_expand(
        ctx: *mut ggml_context,
        cgraph: *mut ggml_cgraph,
        grad_accs: *mut *mut ggml_tensor,
    );
}
extern "C" {
    pub fn ggml_new_graph(ctx: *mut ggml_context) -> *mut ggml_cgraph;
}
extern "C" {
    pub fn ggml_new_graph_custom(
        ctx: *mut ggml_context,
        size: usize,
        grads: bool,
    ) -> *mut ggml_cgraph;
}
extern "C" {
    pub fn ggml_graph_dup(
        ctx: *mut ggml_context,
        cgraph: *mut ggml_cgraph,
        force_grads: bool,
    ) -> *mut ggml_cgraph;
}
extern "C" {
    pub fn ggml_graph_cpy(src: *mut ggml_cgraph, dst: *mut ggml_cgraph);
}
extern "C" {
    pub fn ggml_graph_reset(cgraph: *mut ggml_cgraph);
}
extern "C" {
    pub fn ggml_graph_clear(cgraph: *mut ggml_cgraph);
}
extern "C" {
    pub fn ggml_graph_size(cgraph: *mut ggml_cgraph) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_graph_node(cgraph: *mut ggml_cgraph, i: ::std::os::raw::c_int) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_graph_nodes(cgraph: *mut ggml_cgraph) -> *mut *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_graph_n_nodes(cgraph: *mut ggml_cgraph) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_graph_add_node(cgraph: *mut ggml_cgraph, tensor: *mut ggml_tensor);
}
extern "C" {
    pub fn ggml_graph_overhead() -> usize;
}
extern "C" {
    pub fn ggml_graph_overhead_custom(size: usize, grads: bool) -> usize;
}
extern "C" {
    pub fn ggml_graph_get_tensor(
        cgraph: *const ggml_cgraph,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_graph_get_grad(
        cgraph: *const ggml_cgraph,
        node: *const ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_graph_get_grad_acc(
        cgraph: *const ggml_cgraph,
        node: *const ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_graph_print(cgraph: *const ggml_cgraph);
}
extern "C" {
    pub fn ggml_graph_dump_dot(
        gb: *const ggml_cgraph,
        gf: *const ggml_cgraph,
        filename: *const ::std::os::raw::c_char,
    );
}
pub type ggml_log_callback = ::std::option::Option<
    unsafe extern "C" fn(
        level: ggml_log_level,
        text: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn ggml_log_get(
        log_callback: *mut ggml_log_callback,
        user_data: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn ggml_log_set(log_callback: ggml_log_callback, user_data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn ggml_set_zero(tensor: *mut ggml_tensor) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_quantize_init(type_: ggml_type);
}
extern "C" {
    pub fn ggml_quantize_free();
}
extern "C" {
    pub fn ggml_quantize_requires_imatrix(type_: ggml_type) -> bool;
}
extern "C" {
    pub fn ggml_quantize_chunk(
        type_: ggml_type,
        src: *const f32,
        dst: *mut ::std::os::raw::c_void,
        start: i64,
        nrows: i64,
        n_per_row: i64,
        imatrix: *const f32,
    ) -> usize;
}
pub type ggml_to_float_t = ::std::option::Option<
    unsafe extern "C" fn(x: *const ::std::os::raw::c_void, y: *mut f32, k: i64),
>;
pub type ggml_from_float_t = ::std::option::Option<
    unsafe extern "C" fn(x: *const f32, y: *mut ::std::os::raw::c_void, k: i64),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_type_traits {
    pub type_name: *const ::std::os::raw::c_char,
    pub blck_size: i64,
    pub blck_size_interleave: i64,
    pub type_size: usize,
    pub is_quantized: bool,
    pub to_float: ggml_to_float_t,
    pub from_float_ref: ggml_from_float_t,
}
#[test]
fn bindgen_test_layout_ggml_type_traits() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_type_traits> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_type_traits>(),
        56usize,
        concat!("Size of: ", stringify!(ggml_type_traits))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_type_traits>(),
        8usize,
        concat!("Alignment of ", stringify!(ggml_type_traits))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_type_traits),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blck_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_type_traits),
            "::",
            stringify!(blck_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blck_size_interleave) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_type_traits),
            "::",
            stringify!(blck_size_interleave)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_type_traits),
            "::",
            stringify!(type_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_quantized) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_type_traits),
            "::",
            stringify!(is_quantized)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_float) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_type_traits),
            "::",
            stringify!(to_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).from_float_ref) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_type_traits),
            "::",
            stringify!(from_float_ref)
        )
    );
}
extern "C" {
    pub fn ggml_get_type_traits(type_: ggml_type) -> *const ggml_type_traits;
}
pub const ggml_sched_priority_GGML_SCHED_PRIO_LOW: ggml_sched_priority = -1;
pub const ggml_sched_priority_GGML_SCHED_PRIO_NORMAL: ggml_sched_priority = 0;
pub const ggml_sched_priority_GGML_SCHED_PRIO_MEDIUM: ggml_sched_priority = 1;
pub const ggml_sched_priority_GGML_SCHED_PRIO_HIGH: ggml_sched_priority = 2;
pub const ggml_sched_priority_GGML_SCHED_PRIO_REALTIME: ggml_sched_priority = 3;
pub type ggml_sched_priority = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_threadpool_params {
    pub cpumask: [bool; 512usize],
    pub n_threads: ::std::os::raw::c_int,
    pub prio: ggml_sched_priority,
    pub poll: u32,
    pub strict_cpu: bool,
    pub paused: bool,
}
#[test]
fn bindgen_test_layout_ggml_threadpool_params() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_threadpool_params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_threadpool_params>(),
        528usize,
        concat!("Size of: ", stringify!(ggml_threadpool_params))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_threadpool_params>(),
        4usize,
        concat!("Alignment of ", stringify!(ggml_threadpool_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpumask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_threadpool_params),
            "::",
            stringify!(cpumask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_threads) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_threadpool_params),
            "::",
            stringify!(n_threads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prio) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_threadpool_params),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poll) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_threadpool_params),
            "::",
            stringify!(poll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strict_cpu) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_threadpool_params),
            "::",
            stringify!(strict_cpu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paused) as usize - ptr as usize },
        525usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_threadpool_params),
            "::",
            stringify!(paused)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_threadpool {
    _unused: [u8; 0],
}
pub type ggml_threadpool_t = *mut ggml_threadpool;
extern "C" {
    pub fn ggml_threadpool_params_default(
        n_threads: ::std::os::raw::c_int,
    ) -> ggml_threadpool_params;
}
extern "C" {
    pub fn ggml_threadpool_params_init(
        p: *mut ggml_threadpool_params,
        n_threads: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ggml_threadpool_params_match(
        p0: *const ggml_threadpool_params,
        p1: *const ggml_threadpool_params,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_backend_buffer_type {
    _unused: [u8; 0],
}
pub type ggml_backend_buffer_type_t = *mut ggml_backend_buffer_type;
pub type ggml_backend_buffer_t = *mut ggml_backend_buffer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_backend {
    _unused: [u8; 0],
}
pub type ggml_backend_t = *mut ggml_backend;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_tallocr {
    pub buffer: ggml_backend_buffer_t,
    pub base: *mut ::std::os::raw::c_void,
    pub alignment: usize,
    pub offset: usize,
}
#[test]
fn bindgen_test_layout_ggml_tallocr() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_tallocr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_tallocr>(),
        32usize,
        concat!("Size of: ", stringify!(ggml_tallocr))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_tallocr>(),
        8usize,
        concat!("Alignment of ", stringify!(ggml_tallocr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tallocr),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tallocr),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tallocr),
            "::",
            stringify!(alignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_tallocr),
            "::",
            stringify!(offset)
        )
    );
}
extern "C" {
    pub fn ggml_tallocr_new(buffer: ggml_backend_buffer_t) -> ggml_tallocr;
}
extern "C" {
    pub fn ggml_tallocr_alloc(talloc: *mut ggml_tallocr, tensor: *mut ggml_tensor) -> ggml_status;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_gallocr {
    _unused: [u8; 0],
}
pub type ggml_gallocr_t = *mut ggml_gallocr;
extern "C" {
    pub fn ggml_gallocr_new(buft: ggml_backend_buffer_type_t) -> ggml_gallocr_t;
}
extern "C" {
    pub fn ggml_gallocr_new_n(
        bufts: *mut ggml_backend_buffer_type_t,
        n_bufs: ::std::os::raw::c_int,
    ) -> ggml_gallocr_t;
}
extern "C" {
    pub fn ggml_gallocr_free(galloc: ggml_gallocr_t);
}
extern "C" {
    pub fn ggml_gallocr_reserve(galloc: ggml_gallocr_t, graph: *mut ggml_cgraph) -> bool;
}
extern "C" {
    pub fn ggml_gallocr_reserve_n_size(
        galloc: ggml_gallocr_t,
        graph: *mut ggml_cgraph,
        node_buffer_ids: *const ::std::os::raw::c_int,
        leaf_buffer_ids: *const ::std::os::raw::c_int,
        sizes: *mut usize,
    );
}
extern "C" {
    pub fn ggml_gallocr_reserve_n(
        galloc: ggml_gallocr_t,
        graph: *mut ggml_cgraph,
        node_buffer_ids: *const ::std::os::raw::c_int,
        leaf_buffer_ids: *const ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn ggml_gallocr_alloc_graph(galloc: ggml_gallocr_t, graph: *mut ggml_cgraph) -> bool;
}
extern "C" {
    pub fn ggml_gallocr_get_buffer_size(
        galloc: ggml_gallocr_t,
        buffer_id: ::std::os::raw::c_int,
    ) -> usize;
}
extern "C" {
    pub fn ggml_backend_alloc_ctx_tensors_from_buft_size(
        ctx: *mut ggml_context,
        buft: ggml_backend_buffer_type_t,
    ) -> usize;
}
extern "C" {
    pub fn ggml_backend_alloc_ctx_tensors_from_buft(
        ctx: *mut ggml_context,
        buft: ggml_backend_buffer_type_t,
    ) -> *mut ggml_backend_buffer;
}
extern "C" {
    pub fn ggml_backend_alloc_ctx_tensors(
        ctx: *mut ggml_context,
        backend: ggml_backend_t,
    ) -> *mut ggml_backend_buffer;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_backend_event {
    _unused: [u8; 0],
}
pub type ggml_backend_event_t = *mut ggml_backend_event;
pub type ggml_backend_graph_plan_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_backend_reg {
    _unused: [u8; 0],
}
pub type ggml_backend_reg_t = *mut ggml_backend_reg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_backend_device {
    _unused: [u8; 0],
}
pub type ggml_backend_dev_t = *mut ggml_backend_device;
extern "C" {
    pub fn ggml_backend_buft_name(
        buft: ggml_backend_buffer_type_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_backend_buft_alloc_buffer(
        buft: ggml_backend_buffer_type_t,
        size: usize,
    ) -> ggml_backend_buffer_t;
}
extern "C" {
    pub fn ggml_backend_buft_get_alignment(buft: ggml_backend_buffer_type_t) -> usize;
}
extern "C" {
    pub fn ggml_backend_buft_get_max_size(buft: ggml_backend_buffer_type_t) -> usize;
}
extern "C" {
    pub fn ggml_backend_buft_get_alloc_size(
        buft: ggml_backend_buffer_type_t,
        tensor: *const ggml_tensor,
    ) -> usize;
}
extern "C" {
    pub fn ggml_backend_buft_is_host(buft: ggml_backend_buffer_type_t) -> bool;
}
extern "C" {
    pub fn ggml_backend_buft_get_device(buft: ggml_backend_buffer_type_t) -> ggml_backend_dev_t;
}
pub const ggml_backend_buffer_usage_GGML_BACKEND_BUFFER_USAGE_ANY: ggml_backend_buffer_usage = 0;
pub const ggml_backend_buffer_usage_GGML_BACKEND_BUFFER_USAGE_WEIGHTS: ggml_backend_buffer_usage =
    1;
pub const ggml_backend_buffer_usage_GGML_BACKEND_BUFFER_USAGE_COMPUTE: ggml_backend_buffer_usage =
    2;
pub type ggml_backend_buffer_usage = ::std::os::raw::c_uint;
extern "C" {
    pub fn ggml_backend_buffer_name(buffer: ggml_backend_buffer_t)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_backend_buffer_free(buffer: ggml_backend_buffer_t);
}
extern "C" {
    pub fn ggml_backend_buffer_get_base(
        buffer: ggml_backend_buffer_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ggml_backend_buffer_get_size(buffer: ggml_backend_buffer_t) -> usize;
}
extern "C" {
    pub fn ggml_backend_buffer_init_tensor(
        buffer: ggml_backend_buffer_t,
        tensor: *mut ggml_tensor,
    ) -> ggml_status;
}
extern "C" {
    pub fn ggml_backend_buffer_get_alignment(buffer: ggml_backend_buffer_t) -> usize;
}
extern "C" {
    pub fn ggml_backend_buffer_get_max_size(buffer: ggml_backend_buffer_t) -> usize;
}
extern "C" {
    pub fn ggml_backend_buffer_get_alloc_size(
        buffer: ggml_backend_buffer_t,
        tensor: *const ggml_tensor,
    ) -> usize;
}
extern "C" {
    pub fn ggml_backend_buffer_clear(buffer: ggml_backend_buffer_t, value: u8);
}
extern "C" {
    pub fn ggml_backend_buffer_is_host(buffer: ggml_backend_buffer_t) -> bool;
}
extern "C" {
    pub fn ggml_backend_buffer_set_usage(
        buffer: ggml_backend_buffer_t,
        usage: ggml_backend_buffer_usage,
    );
}
extern "C" {
    pub fn ggml_backend_buffer_get_usage(
        buffer: ggml_backend_buffer_t,
    ) -> ggml_backend_buffer_usage;
}
extern "C" {
    pub fn ggml_backend_buffer_get_type(
        buffer: ggml_backend_buffer_t,
    ) -> ggml_backend_buffer_type_t;
}
extern "C" {
    pub fn ggml_backend_buffer_reset(buffer: ggml_backend_buffer_t);
}
extern "C" {
    pub fn ggml_backend_tensor_copy(src: *mut ggml_tensor, dst: *mut ggml_tensor);
}
extern "C" {
    pub fn ggml_backend_guid(backend: ggml_backend_t) -> ggml_guid_t;
}
extern "C" {
    pub fn ggml_backend_name(backend: ggml_backend_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_backend_free(backend: ggml_backend_t);
}
extern "C" {
    pub fn ggml_backend_get_default_buffer_type(
        backend: ggml_backend_t,
    ) -> ggml_backend_buffer_type_t;
}
extern "C" {
    pub fn ggml_backend_alloc_buffer(backend: ggml_backend_t, size: usize)
        -> ggml_backend_buffer_t;
}
extern "C" {
    pub fn ggml_backend_get_alignment(backend: ggml_backend_t) -> usize;
}
extern "C" {
    pub fn ggml_backend_get_max_size(backend: ggml_backend_t) -> usize;
}
extern "C" {
    pub fn ggml_backend_tensor_set_async(
        backend: ggml_backend_t,
        tensor: *mut ggml_tensor,
        data: *const ::std::os::raw::c_void,
        offset: usize,
        size: usize,
    );
}
extern "C" {
    pub fn ggml_backend_tensor_get_async(
        backend: ggml_backend_t,
        tensor: *const ggml_tensor,
        data: *mut ::std::os::raw::c_void,
        offset: usize,
        size: usize,
    );
}
extern "C" {
    pub fn ggml_backend_tensor_set(
        tensor: *mut ggml_tensor,
        data: *const ::std::os::raw::c_void,
        offset: usize,
        size: usize,
    );
}
extern "C" {
    pub fn ggml_backend_tensor_get(
        tensor: *const ggml_tensor,
        data: *mut ::std::os::raw::c_void,
        offset: usize,
        size: usize,
    );
}
extern "C" {
    pub fn ggml_backend_tensor_memset(
        tensor: *mut ggml_tensor,
        value: u8,
        offset: usize,
        size: usize,
    );
}
extern "C" {
    pub fn ggml_backend_synchronize(backend: ggml_backend_t);
}
extern "C" {
    pub fn ggml_backend_graph_plan_create(
        backend: ggml_backend_t,
        cgraph: *mut ggml_cgraph,
    ) -> ggml_backend_graph_plan_t;
}
extern "C" {
    pub fn ggml_backend_graph_plan_free(backend: ggml_backend_t, plan: ggml_backend_graph_plan_t);
}
extern "C" {
    pub fn ggml_backend_graph_plan_compute(
        backend: ggml_backend_t,
        plan: ggml_backend_graph_plan_t,
    ) -> ggml_status;
}
extern "C" {
    pub fn ggml_backend_graph_compute(
        backend: ggml_backend_t,
        cgraph: *mut ggml_cgraph,
    ) -> ggml_status;
}
extern "C" {
    pub fn ggml_backend_graph_compute_async(
        backend: ggml_backend_t,
        cgraph: *mut ggml_cgraph,
    ) -> ggml_status;
}
extern "C" {
    pub fn ggml_backend_supports_op(backend: ggml_backend_t, op: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_backend_supports_buft(
        backend: ggml_backend_t,
        buft: ggml_backend_buffer_type_t,
    ) -> bool;
}
extern "C" {
    pub fn ggml_backend_offload_op(backend: ggml_backend_t, op: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_backend_tensor_copy_async(
        backend_src: ggml_backend_t,
        backend_dst: ggml_backend_t,
        src: *mut ggml_tensor,
        dst: *mut ggml_tensor,
    );
}
extern "C" {
    pub fn ggml_backend_get_device(backend: ggml_backend_t) -> ggml_backend_dev_t;
}
extern "C" {
    pub fn ggml_backend_event_new(device: ggml_backend_dev_t) -> ggml_backend_event_t;
}
extern "C" {
    pub fn ggml_backend_event_free(event: ggml_backend_event_t);
}
extern "C" {
    pub fn ggml_backend_event_record(event: ggml_backend_event_t, backend: ggml_backend_t);
}
extern "C" {
    pub fn ggml_backend_event_synchronize(event: ggml_backend_event_t);
}
extern "C" {
    pub fn ggml_backend_event_wait(backend: ggml_backend_t, event: ggml_backend_event_t);
}
pub const ggml_backend_dev_type_GGML_BACKEND_DEVICE_TYPE_CPU: ggml_backend_dev_type = 0;
pub const ggml_backend_dev_type_GGML_BACKEND_DEVICE_TYPE_GPU: ggml_backend_dev_type = 1;
pub const ggml_backend_dev_type_GGML_BACKEND_DEVICE_TYPE_IGPU: ggml_backend_dev_type = 2;
pub const ggml_backend_dev_type_GGML_BACKEND_DEVICE_TYPE_ACCEL: ggml_backend_dev_type = 3;
pub type ggml_backend_dev_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_backend_dev_caps {
    pub async_: bool,
    pub host_buffer: bool,
    pub buffer_from_host_ptr: bool,
    pub events: bool,
}
#[test]
fn bindgen_test_layout_ggml_backend_dev_caps() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_backend_dev_caps> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_backend_dev_caps>(),
        4usize,
        concat!("Size of: ", stringify!(ggml_backend_dev_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_backend_dev_caps>(),
        1usize,
        concat!("Alignment of ", stringify!(ggml_backend_dev_caps))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).async_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_dev_caps),
            "::",
            stringify!(async_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_buffer) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_dev_caps),
            "::",
            stringify!(host_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_from_host_ptr) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_dev_caps),
            "::",
            stringify!(buffer_from_host_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_dev_caps),
            "::",
            stringify!(events)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_backend_dev_props {
    pub name: *const ::std::os::raw::c_char,
    pub description: *const ::std::os::raw::c_char,
    pub memory_free: usize,
    pub memory_total: usize,
    pub type_: ggml_backend_dev_type,
    pub device_id: *const ::std::os::raw::c_char,
    pub caps: ggml_backend_dev_caps,
}
#[test]
fn bindgen_test_layout_ggml_backend_dev_props() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_backend_dev_props> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_backend_dev_props>(),
        56usize,
        concat!("Size of: ", stringify!(ggml_backend_dev_props))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_backend_dev_props>(),
        8usize,
        concat!("Alignment of ", stringify!(ggml_backend_dev_props))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_dev_props),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_dev_props),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_free) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_dev_props),
            "::",
            stringify!(memory_free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_total) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_dev_props),
            "::",
            stringify!(memory_total)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_dev_props),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_dev_props),
            "::",
            stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).caps) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_dev_props),
            "::",
            stringify!(caps)
        )
    );
}
extern "C" {
    pub fn ggml_backend_dev_name(device: ggml_backend_dev_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_backend_dev_description(
        device: ggml_backend_dev_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_backend_dev_memory(device: ggml_backend_dev_t, free: *mut usize, total: *mut usize);
}
extern "C" {
    pub fn ggml_backend_dev_type(device: ggml_backend_dev_t) -> ggml_backend_dev_type;
}
extern "C" {
    pub fn ggml_backend_dev_get_props(
        device: ggml_backend_dev_t,
        props: *mut ggml_backend_dev_props,
    );
}
extern "C" {
    pub fn ggml_backend_dev_backend_reg(device: ggml_backend_dev_t) -> ggml_backend_reg_t;
}
extern "C" {
    pub fn ggml_backend_dev_init(
        device: ggml_backend_dev_t,
        params: *const ::std::os::raw::c_char,
    ) -> ggml_backend_t;
}
extern "C" {
    pub fn ggml_backend_dev_buffer_type(device: ggml_backend_dev_t) -> ggml_backend_buffer_type_t;
}
extern "C" {
    pub fn ggml_backend_dev_host_buffer_type(
        device: ggml_backend_dev_t,
    ) -> ggml_backend_buffer_type_t;
}
extern "C" {
    pub fn ggml_backend_dev_buffer_from_host_ptr(
        device: ggml_backend_dev_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        max_tensor_size: usize,
    ) -> ggml_backend_buffer_t;
}
extern "C" {
    pub fn ggml_backend_dev_supports_op(device: ggml_backend_dev_t, op: *const ggml_tensor)
        -> bool;
}
extern "C" {
    pub fn ggml_backend_dev_supports_buft(
        device: ggml_backend_dev_t,
        buft: ggml_backend_buffer_type_t,
    ) -> bool;
}
extern "C" {
    pub fn ggml_backend_dev_offload_op(device: ggml_backend_dev_t, op: *const ggml_tensor) -> bool;
}
extern "C" {
    pub fn ggml_backend_reg_name(reg: ggml_backend_reg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_backend_reg_dev_count(reg: ggml_backend_reg_t) -> usize;
}
extern "C" {
    pub fn ggml_backend_reg_dev_get(reg: ggml_backend_reg_t, index: usize) -> ggml_backend_dev_t;
}
extern "C" {
    pub fn ggml_backend_reg_get_proc_address(
        reg: ggml_backend_reg_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
pub type ggml_backend_split_buffer_type_t = ::std::option::Option<
    unsafe extern "C" fn(
        main_device: ::std::os::raw::c_int,
        tensor_split: *const f32,
    ) -> ggml_backend_buffer_type_t,
>;
pub type ggml_backend_set_n_threads_t = ::std::option::Option<
    unsafe extern "C" fn(backend: ggml_backend_t, n_threads: ::std::os::raw::c_int),
>;
pub type ggml_backend_dev_get_extra_bufts_t = ::std::option::Option<
    unsafe extern "C" fn(device: ggml_backend_dev_t) -> *mut ggml_backend_buffer_type_t,
>;
pub type ggml_backend_set_abort_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        backend: ggml_backend_t,
        abort_callback: ggml_abort_callback,
        abort_callback_data: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_backend_feature {
    pub name: *const ::std::os::raw::c_char,
    pub value: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ggml_backend_feature() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_backend_feature> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_backend_feature>(),
        16usize,
        concat!("Size of: ", stringify!(ggml_backend_feature))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_backend_feature>(),
        8usize,
        concat!("Alignment of ", stringify!(ggml_backend_feature))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_feature),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_feature),
            "::",
            stringify!(value)
        )
    );
}
pub type ggml_backend_get_features_t = ::std::option::Option<
    unsafe extern "C" fn(reg: ggml_backend_reg_t) -> *mut ggml_backend_feature,
>;
extern "C" {
    pub fn ggml_backend_register(reg: ggml_backend_reg_t);
}
extern "C" {
    pub fn ggml_backend_device_register(device: ggml_backend_dev_t);
}
extern "C" {
    pub fn ggml_backend_reg_count() -> usize;
}
extern "C" {
    pub fn ggml_backend_reg_get(index: usize) -> ggml_backend_reg_t;
}
extern "C" {
    pub fn ggml_backend_reg_by_name(name: *const ::std::os::raw::c_char) -> ggml_backend_reg_t;
}
extern "C" {
    pub fn ggml_backend_dev_count() -> usize;
}
extern "C" {
    pub fn ggml_backend_dev_get(index: usize) -> ggml_backend_dev_t;
}
extern "C" {
    pub fn ggml_backend_dev_by_name(name: *const ::std::os::raw::c_char) -> ggml_backend_dev_t;
}
extern "C" {
    pub fn ggml_backend_dev_by_type(type_: ggml_backend_dev_type) -> ggml_backend_dev_t;
}
extern "C" {
    pub fn ggml_backend_init_by_name(
        name: *const ::std::os::raw::c_char,
        params: *const ::std::os::raw::c_char,
    ) -> ggml_backend_t;
}
extern "C" {
    pub fn ggml_backend_init_by_type(
        type_: ggml_backend_dev_type,
        params: *const ::std::os::raw::c_char,
    ) -> ggml_backend_t;
}
extern "C" {
    pub fn ggml_backend_init_best() -> ggml_backend_t;
}
extern "C" {
    pub fn ggml_backend_load(path: *const ::std::os::raw::c_char) -> ggml_backend_reg_t;
}
extern "C" {
    pub fn ggml_backend_unload(reg: ggml_backend_reg_t);
}
extern "C" {
    pub fn ggml_backend_load_all();
}
extern "C" {
    pub fn ggml_backend_load_all_from_path(dir_path: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_backend_sched {
    _unused: [u8; 0],
}
pub type ggml_backend_sched_t = *mut ggml_backend_sched;
pub type ggml_backend_sched_eval_callback = ::std::option::Option<
    unsafe extern "C" fn(
        t: *mut ggml_tensor,
        ask: bool,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
extern "C" {
    pub fn ggml_backend_sched_new(
        backends: *mut ggml_backend_t,
        bufts: *mut ggml_backend_buffer_type_t,
        n_backends: ::std::os::raw::c_int,
        graph_size: usize,
        parallel: bool,
        op_offload: bool,
    ) -> ggml_backend_sched_t;
}
extern "C" {
    pub fn ggml_backend_sched_free(sched: ggml_backend_sched_t);
}
extern "C" {
    pub fn ggml_backend_sched_reserve_size(
        sched: ggml_backend_sched_t,
        measure_graph: *mut ggml_cgraph,
        sizes: *mut usize,
    );
}
extern "C" {
    pub fn ggml_backend_sched_reserve(
        sched: ggml_backend_sched_t,
        measure_graph: *mut ggml_cgraph,
    ) -> bool;
}
extern "C" {
    pub fn ggml_backend_sched_get_n_backends(sched: ggml_backend_sched_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_backend_sched_get_backend(
        sched: ggml_backend_sched_t,
        i: ::std::os::raw::c_int,
    ) -> ggml_backend_t;
}
extern "C" {
    pub fn ggml_backend_sched_get_n_splits(sched: ggml_backend_sched_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_backend_sched_get_n_copies(sched: ggml_backend_sched_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_backend_sched_get_buffer_type(
        sched: ggml_backend_sched_t,
        backend: ggml_backend_t,
    ) -> ggml_backend_buffer_type_t;
}
extern "C" {
    pub fn ggml_backend_sched_get_buffer_size(
        sched: ggml_backend_sched_t,
        backend: ggml_backend_t,
    ) -> usize;
}
extern "C" {
    pub fn ggml_backend_sched_set_tensor_backend(
        sched: ggml_backend_sched_t,
        node: *mut ggml_tensor,
        backend: ggml_backend_t,
    );
}
extern "C" {
    pub fn ggml_backend_sched_get_tensor_backend(
        sched: ggml_backend_sched_t,
        node: *mut ggml_tensor,
    ) -> ggml_backend_t;
}
extern "C" {
    pub fn ggml_backend_sched_split_graph(sched: ggml_backend_sched_t, graph: *mut ggml_cgraph);
}
extern "C" {
    pub fn ggml_backend_sched_alloc_graph(
        sched: ggml_backend_sched_t,
        graph: *mut ggml_cgraph,
    ) -> bool;
}
extern "C" {
    pub fn ggml_backend_sched_graph_compute(
        sched: ggml_backend_sched_t,
        graph: *mut ggml_cgraph,
    ) -> ggml_status;
}
extern "C" {
    pub fn ggml_backend_sched_graph_compute_async(
        sched: ggml_backend_sched_t,
        graph: *mut ggml_cgraph,
    ) -> ggml_status;
}
extern "C" {
    pub fn ggml_backend_sched_synchronize(sched: ggml_backend_sched_t);
}
extern "C" {
    pub fn ggml_backend_sched_reset(sched: ggml_backend_sched_t);
}
extern "C" {
    pub fn ggml_backend_sched_set_eval_callback(
        sched: ggml_backend_sched_t,
        callback: ggml_backend_sched_eval_callback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_backend_graph_copy {
    pub buffer: ggml_backend_buffer_t,
    pub ctx_allocated: *mut ggml_context,
    pub ctx_unallocated: *mut ggml_context,
    pub graph: *mut ggml_cgraph,
}
#[test]
fn bindgen_test_layout_ggml_backend_graph_copy() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_backend_graph_copy> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_backend_graph_copy>(),
        32usize,
        concat!("Size of: ", stringify!(ggml_backend_graph_copy))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_backend_graph_copy>(),
        8usize,
        concat!("Alignment of ", stringify!(ggml_backend_graph_copy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_graph_copy),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx_allocated) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_graph_copy),
            "::",
            stringify!(ctx_allocated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx_unallocated) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_graph_copy),
            "::",
            stringify!(ctx_unallocated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graph) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_backend_graph_copy),
            "::",
            stringify!(graph)
        )
    );
}
extern "C" {
    pub fn ggml_backend_graph_copy(
        backend: ggml_backend_t,
        graph: *mut ggml_cgraph,
    ) -> ggml_backend_graph_copy;
}
extern "C" {
    pub fn ggml_backend_graph_copy_free(copy: ggml_backend_graph_copy);
}
pub type ggml_backend_eval_callback = ::std::option::Option<
    unsafe extern "C" fn(
        node_index: ::std::os::raw::c_int,
        t1: *mut ggml_tensor,
        t2: *mut ggml_tensor,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
extern "C" {
    pub fn ggml_backend_compare_graph_backend(
        backend1: ggml_backend_t,
        backend2: ggml_backend_t,
        graph: *mut ggml_cgraph,
        callback: ggml_backend_eval_callback,
        user_data: *mut ::std::os::raw::c_void,
        test_nodes: *const *const ggml_tensor,
        num_test_nodes: usize,
    ) -> bool;
}
extern "C" {
    pub fn ggml_backend_tensor_alloc(
        buffer: ggml_backend_buffer_t,
        tensor: *mut ggml_tensor,
        addr: *mut ::std::os::raw::c_void,
    ) -> ggml_status;
}
extern "C" {
    pub fn ggml_backend_view_init(tensor: *mut ggml_tensor) -> ggml_status;
}
extern "C" {
    pub fn ggml_backend_cpu_buffer_from_ptr(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> ggml_backend_buffer_t;
}
extern "C" {
    pub fn ggml_backend_cpu_buffer_type() -> ggml_backend_buffer_type_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_cplan {
    pub work_size: usize,
    pub work_data: *mut u8,
    pub n_threads: ::std::os::raw::c_int,
    pub threadpool: *mut ggml_threadpool,
    pub abort_callback: ggml_abort_callback,
    pub abort_callback_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ggml_cplan() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_cplan> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_cplan>(),
        48usize,
        concat!("Size of: ", stringify!(ggml_cplan))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_cplan>(),
        8usize,
        concat!("Alignment of ", stringify!(ggml_cplan))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).work_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_cplan),
            "::",
            stringify!(work_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).work_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_cplan),
            "::",
            stringify!(work_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_threads) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_cplan),
            "::",
            stringify!(n_threads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threadpool) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_cplan),
            "::",
            stringify!(threadpool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abort_callback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_cplan),
            "::",
            stringify!(abort_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abort_callback_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_cplan),
            "::",
            stringify!(abort_callback_data)
        )
    );
}
pub const ggml_numa_strategy_GGML_NUMA_STRATEGY_DISABLED: ggml_numa_strategy = 0;
pub const ggml_numa_strategy_GGML_NUMA_STRATEGY_DISTRIBUTE: ggml_numa_strategy = 1;
pub const ggml_numa_strategy_GGML_NUMA_STRATEGY_ISOLATE: ggml_numa_strategy = 2;
pub const ggml_numa_strategy_GGML_NUMA_STRATEGY_NUMACTL: ggml_numa_strategy = 3;
pub const ggml_numa_strategy_GGML_NUMA_STRATEGY_MIRROR: ggml_numa_strategy = 4;
pub const ggml_numa_strategy_GGML_NUMA_STRATEGY_COUNT: ggml_numa_strategy = 5;
pub type ggml_numa_strategy = ::std::os::raw::c_uint;
extern "C" {
    pub fn ggml_numa_init(numa: ggml_numa_strategy);
}
extern "C" {
    pub fn ggml_is_numa() -> bool;
}
extern "C" {
    pub fn ggml_new_i32(ctx: *mut ggml_context, value: i32) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_new_f32(ctx: *mut ggml_context, value: f32) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_set_i32(tensor: *mut ggml_tensor, value: i32) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_set_f32(tensor: *mut ggml_tensor, value: f32) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_get_i32_1d(tensor: *const ggml_tensor, i: ::std::os::raw::c_int) -> i32;
}
extern "C" {
    pub fn ggml_set_i32_1d(tensor: *const ggml_tensor, i: ::std::os::raw::c_int, value: i32);
}
extern "C" {
    pub fn ggml_get_i32_nd(
        tensor: *const ggml_tensor,
        i0: ::std::os::raw::c_int,
        i1: ::std::os::raw::c_int,
        i2: ::std::os::raw::c_int,
        i3: ::std::os::raw::c_int,
    ) -> i32;
}
extern "C" {
    pub fn ggml_set_i32_nd(
        tensor: *const ggml_tensor,
        i0: ::std::os::raw::c_int,
        i1: ::std::os::raw::c_int,
        i2: ::std::os::raw::c_int,
        i3: ::std::os::raw::c_int,
        value: i32,
    );
}
extern "C" {
    pub fn ggml_get_f32_1d(tensor: *const ggml_tensor, i: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ggml_set_f32_1d(tensor: *const ggml_tensor, i: ::std::os::raw::c_int, value: f32);
}
extern "C" {
    pub fn ggml_get_f32_nd(
        tensor: *const ggml_tensor,
        i0: ::std::os::raw::c_int,
        i1: ::std::os::raw::c_int,
        i2: ::std::os::raw::c_int,
        i3: ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    pub fn ggml_set_f32_nd(
        tensor: *const ggml_tensor,
        i0: ::std::os::raw::c_int,
        i1: ::std::os::raw::c_int,
        i2: ::std::os::raw::c_int,
        i3: ::std::os::raw::c_int,
        value: f32,
    );
}
extern "C" {
    pub fn ggml_threadpool_new(params: *mut ggml_threadpool_params) -> *mut ggml_threadpool;
}
extern "C" {
    pub fn ggml_threadpool_free(threadpool: *mut ggml_threadpool);
}
extern "C" {
    pub fn ggml_threadpool_get_n_threads(threadpool: *mut ggml_threadpool)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_threadpool_pause(threadpool: *mut ggml_threadpool);
}
extern "C" {
    pub fn ggml_threadpool_resume(threadpool: *mut ggml_threadpool);
}
extern "C" {
    pub fn ggml_graph_plan(
        cgraph: *const ggml_cgraph,
        n_threads: ::std::os::raw::c_int,
        threadpool: *mut ggml_threadpool,
    ) -> ggml_cplan;
}
extern "C" {
    pub fn ggml_graph_compute(cgraph: *mut ggml_cgraph, cplan: *mut ggml_cplan) -> ggml_status;
}
extern "C" {
    pub fn ggml_graph_compute_with_ctx(
        ctx: *mut ggml_context,
        cgraph: *mut ggml_cgraph,
        n_threads: ::std::os::raw::c_int,
    ) -> ggml_status;
}
extern "C" {
    pub fn ggml_cpu_has_sse3() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_ssse3() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_avx() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_avx_vnni() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_avx2() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_bmi2() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_f16c() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_fma() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_avx512() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_avx512_vbmi() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_avx512_vnni() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_avx512_bf16() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_amx_int8() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_neon() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_arm_fma() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_fp16_va() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_dotprod() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_matmul_int8() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_sve() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_get_sve_cnt() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_sme() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_riscv_v() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_get_rvv_vlen() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_vsx() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_vxe() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_wasm_simd() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ggml_cpu_has_llamafile() -> ::std::os::raw::c_int;
}
pub type ggml_vec_dot_t = ::std::option::Option<
    unsafe extern "C" fn(
        n: ::std::os::raw::c_int,
        s: *mut f32,
        bs: usize,
        x: *const ::std::os::raw::c_void,
        bx: usize,
        y: *const ::std::os::raw::c_void,
        by: usize,
        nrc: ::std::os::raw::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_type_traits_cpu {
    pub from_float: ggml_from_float_t,
    pub vec_dot: ggml_vec_dot_t,
    pub vec_dot_type: ggml_type,
    pub nrows: i64,
}
#[test]
fn bindgen_test_layout_ggml_type_traits_cpu() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_type_traits_cpu> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_type_traits_cpu>(),
        32usize,
        concat!("Size of: ", stringify!(ggml_type_traits_cpu))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_type_traits_cpu>(),
        8usize,
        concat!("Alignment of ", stringify!(ggml_type_traits_cpu))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).from_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_type_traits_cpu),
            "::",
            stringify!(from_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vec_dot) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_type_traits_cpu),
            "::",
            stringify!(vec_dot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vec_dot_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_type_traits_cpu),
            "::",
            stringify!(vec_dot_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nrows) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_type_traits_cpu),
            "::",
            stringify!(nrows)
        )
    );
}
extern "C" {
    pub fn ggml_get_type_traits_cpu(type_: ggml_type) -> *const ggml_type_traits_cpu;
}
extern "C" {
    pub fn ggml_cpu_init();
}
extern "C" {
    pub fn ggml_backend_cpu_init() -> ggml_backend_t;
}
extern "C" {
    pub fn ggml_backend_is_cpu(backend: ggml_backend_t) -> bool;
}
extern "C" {
    pub fn ggml_backend_cpu_set_n_threads(
        backend_cpu: ggml_backend_t,
        n_threads: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ggml_backend_cpu_set_threadpool(
        backend_cpu: ggml_backend_t,
        threadpool: ggml_threadpool_t,
    );
}
extern "C" {
    pub fn ggml_backend_cpu_set_abort_callback(
        backend_cpu: ggml_backend_t,
        abort_callback: ggml_abort_callback,
        abort_callback_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn ggml_backend_cpu_reg() -> ggml_backend_reg_t;
}
extern "C" {
    pub fn ggml_cpu_fp32_to_fp32(arg1: *const f32, arg2: *mut f32, arg3: i64);
}
extern "C" {
    pub fn ggml_cpu_fp32_to_i32(arg1: *const f32, arg2: *mut i32, arg3: i64);
}
extern "C" {
    pub fn ggml_cpu_fp32_to_fp16(arg1: *const f32, arg2: *mut ggml_fp16_t, arg3: i64);
}
extern "C" {
    pub fn ggml_cpu_fp16_to_fp32(arg1: *const ggml_fp16_t, arg2: *mut f32, arg3: i64);
}
extern "C" {
    pub fn ggml_cpu_fp32_to_bf16(arg1: *const f32, arg2: *mut ggml_bf16_t, arg3: i64);
}
extern "C" {
    pub fn ggml_cpu_bf16_to_fp32(arg1: *const ggml_bf16_t, arg2: *mut f32, arg3: i64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_opt_dataset {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_opt_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_opt_result {
    _unused: [u8; 0],
}
pub type ggml_opt_dataset_t = *mut ggml_opt_dataset;
pub type ggml_opt_context_t = *mut ggml_opt_context;
pub type ggml_opt_result_t = *mut ggml_opt_result;
pub const ggml_opt_loss_type_GGML_OPT_LOSS_TYPE_MEAN: ggml_opt_loss_type = 0;
pub const ggml_opt_loss_type_GGML_OPT_LOSS_TYPE_SUM: ggml_opt_loss_type = 1;
pub const ggml_opt_loss_type_GGML_OPT_LOSS_TYPE_CROSS_ENTROPY: ggml_opt_loss_type = 2;
pub const ggml_opt_loss_type_GGML_OPT_LOSS_TYPE_MEAN_SQUARED_ERROR: ggml_opt_loss_type = 3;
pub type ggml_opt_loss_type = ::std::os::raw::c_uint;
extern "C" {
    pub fn ggml_opt_dataset_init(
        type_data: ggml_type,
        type_label: ggml_type,
        ne_datapoint: i64,
        ne_label: i64,
        ndata: i64,
        ndata_shard: i64,
    ) -> ggml_opt_dataset_t;
}
extern "C" {
    pub fn ggml_opt_dataset_free(dataset: ggml_opt_dataset_t);
}
extern "C" {
    pub fn ggml_opt_dataset_ndata(dataset: ggml_opt_dataset_t) -> i64;
}
extern "C" {
    pub fn ggml_opt_dataset_data(dataset: ggml_opt_dataset_t) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_opt_dataset_labels(dataset: ggml_opt_dataset_t) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_opt_dataset_shuffle(
        opt_ctx: ggml_opt_context_t,
        dataset: ggml_opt_dataset_t,
        idata: i64,
    );
}
extern "C" {
    pub fn ggml_opt_dataset_get_batch(
        dataset: ggml_opt_dataset_t,
        data_batch: *mut ggml_tensor,
        labels_batch: *mut ggml_tensor,
        ibatch: i64,
    );
}
extern "C" {
    pub fn ggml_opt_dataset_get_batch_host(
        dataset: ggml_opt_dataset_t,
        data_batch: *mut ::std::os::raw::c_void,
        nb_data_batch: usize,
        labels_batch: *mut ::std::os::raw::c_void,
        ibatch: i64,
    );
}
pub const ggml_opt_build_type_GGML_OPT_BUILD_TYPE_FORWARD: ggml_opt_build_type = 10;
pub const ggml_opt_build_type_GGML_OPT_BUILD_TYPE_GRAD: ggml_opt_build_type = 20;
pub const ggml_opt_build_type_GGML_OPT_BUILD_TYPE_OPT: ggml_opt_build_type = 30;
pub type ggml_opt_build_type = ::std::os::raw::c_uint;
pub const ggml_opt_optimizer_type_GGML_OPT_OPTIMIZER_TYPE_ADAMW: ggml_opt_optimizer_type = 0;
pub const ggml_opt_optimizer_type_GGML_OPT_OPTIMIZER_TYPE_SGD: ggml_opt_optimizer_type = 1;
pub const ggml_opt_optimizer_type_GGML_OPT_OPTIMIZER_TYPE_COUNT: ggml_opt_optimizer_type = 2;
pub type ggml_opt_optimizer_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_opt_optimizer_params {
    pub adamw: ggml_opt_optimizer_params__bindgen_ty_1,
    pub sgd: ggml_opt_optimizer_params__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_opt_optimizer_params__bindgen_ty_1 {
    pub alpha: f32,
    pub beta1: f32,
    pub beta2: f32,
    pub eps: f32,
    pub wd: f32,
}
#[test]
fn bindgen_test_layout_ggml_opt_optimizer_params__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_opt_optimizer_params__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_opt_optimizer_params__bindgen_ty_1>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(ggml_opt_optimizer_params__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_opt_optimizer_params__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ggml_opt_optimizer_params__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpha) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_opt_optimizer_params__bindgen_ty_1),
            "::",
            stringify!(alpha)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).beta1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_opt_optimizer_params__bindgen_ty_1),
            "::",
            stringify!(beta1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).beta2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_opt_optimizer_params__bindgen_ty_1),
            "::",
            stringify!(beta2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eps) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_opt_optimizer_params__bindgen_ty_1),
            "::",
            stringify!(eps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wd) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_opt_optimizer_params__bindgen_ty_1),
            "::",
            stringify!(wd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_opt_optimizer_params__bindgen_ty_2 {
    pub alpha: f32,
    pub wd: f32,
}
#[test]
fn bindgen_test_layout_ggml_opt_optimizer_params__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_opt_optimizer_params__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_opt_optimizer_params__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(ggml_opt_optimizer_params__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_opt_optimizer_params__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ggml_opt_optimizer_params__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpha) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_opt_optimizer_params__bindgen_ty_2),
            "::",
            stringify!(alpha)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_opt_optimizer_params__bindgen_ty_2),
            "::",
            stringify!(wd)
        )
    );
}
#[test]
fn bindgen_test_layout_ggml_opt_optimizer_params() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_opt_optimizer_params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_opt_optimizer_params>(),
        28usize,
        concat!("Size of: ", stringify!(ggml_opt_optimizer_params))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_opt_optimizer_params>(),
        4usize,
        concat!("Alignment of ", stringify!(ggml_opt_optimizer_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adamw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_opt_optimizer_params),
            "::",
            stringify!(adamw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sgd) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_opt_optimizer_params),
            "::",
            stringify!(sgd)
        )
    );
}
pub type ggml_opt_get_optimizer_params = ::std::option::Option<
    unsafe extern "C" fn(userdata: *mut ::std::os::raw::c_void) -> ggml_opt_optimizer_params,
>;
extern "C" {
    pub fn ggml_opt_get_default_optimizer_params(
        userdata: *mut ::std::os::raw::c_void,
    ) -> ggml_opt_optimizer_params;
}
extern "C" {
    pub fn ggml_opt_get_constant_optimizer_params(
        userdata: *mut ::std::os::raw::c_void,
    ) -> ggml_opt_optimizer_params;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_opt_params {
    pub backend_sched: ggml_backend_sched_t,
    pub ctx_compute: *mut ggml_context,
    pub inputs: *mut ggml_tensor,
    pub outputs: *mut ggml_tensor,
    pub loss_type: ggml_opt_loss_type,
    pub build_type: ggml_opt_build_type,
    pub opt_period: i32,
    pub get_opt_pars: ggml_opt_get_optimizer_params,
    pub get_opt_pars_ud: *mut ::std::os::raw::c_void,
    pub optimizer: ggml_opt_optimizer_type,
}
#[test]
fn bindgen_test_layout_ggml_opt_params() {
    const UNINIT: ::std::mem::MaybeUninit<ggml_opt_params> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ggml_opt_params>(),
        72usize,
        concat!("Size of: ", stringify!(ggml_opt_params))
    );
    assert_eq!(
        ::std::mem::align_of::<ggml_opt_params>(),
        8usize,
        concat!("Alignment of ", stringify!(ggml_opt_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backend_sched) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_opt_params),
            "::",
            stringify!(backend_sched)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx_compute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_opt_params),
            "::",
            stringify!(ctx_compute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_opt_params),
            "::",
            stringify!(inputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_opt_params),
            "::",
            stringify!(outputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loss_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_opt_params),
            "::",
            stringify!(loss_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).build_type) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_opt_params),
            "::",
            stringify!(build_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opt_period) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_opt_params),
            "::",
            stringify!(opt_period)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_opt_pars) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_opt_params),
            "::",
            stringify!(get_opt_pars)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_opt_pars_ud) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_opt_params),
            "::",
            stringify!(get_opt_pars_ud)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optimizer) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ggml_opt_params),
            "::",
            stringify!(optimizer)
        )
    );
}
extern "C" {
    pub fn ggml_opt_default_params(
        backend_sched: ggml_backend_sched_t,
        loss_type: ggml_opt_loss_type,
    ) -> ggml_opt_params;
}
extern "C" {
    pub fn ggml_opt_init(params: ggml_opt_params) -> ggml_opt_context_t;
}
extern "C" {
    pub fn ggml_opt_free(opt_ctx: ggml_opt_context_t);
}
extern "C" {
    pub fn ggml_opt_reset(opt_ctx: ggml_opt_context_t, optimizer: bool);
}
extern "C" {
    pub fn ggml_opt_static_graphs(opt_ctx: ggml_opt_context_t) -> bool;
}
extern "C" {
    pub fn ggml_opt_inputs(opt_ctx: ggml_opt_context_t) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_opt_outputs(opt_ctx: ggml_opt_context_t) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_opt_labels(opt_ctx: ggml_opt_context_t) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_opt_loss(opt_ctx: ggml_opt_context_t) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_opt_pred(opt_ctx: ggml_opt_context_t) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_opt_ncorrect(opt_ctx: ggml_opt_context_t) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_opt_grad_acc(
        opt_ctx: ggml_opt_context_t,
        node: *mut ggml_tensor,
    ) -> *mut ggml_tensor;
}
extern "C" {
    pub fn ggml_opt_context_optimizer_type(arg1: ggml_opt_context_t) -> ggml_opt_optimizer_type;
}
extern "C" {
    pub fn ggml_opt_optimizer_name(arg1: ggml_opt_optimizer_type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ggml_opt_result_init() -> ggml_opt_result_t;
}
extern "C" {
    pub fn ggml_opt_result_free(result: ggml_opt_result_t);
}
extern "C" {
    pub fn ggml_opt_result_reset(result: ggml_opt_result_t);
}
extern "C" {
    pub fn ggml_opt_result_ndata(result: ggml_opt_result_t, ndata: *mut i64);
}
extern "C" {
    pub fn ggml_opt_result_loss(result: ggml_opt_result_t, loss: *mut f64, unc: *mut f64);
}
extern "C" {
    pub fn ggml_opt_result_pred(result: ggml_opt_result_t, pred: *mut i32);
}
extern "C" {
    pub fn ggml_opt_result_accuracy(result: ggml_opt_result_t, accuracy: *mut f64, unc: *mut f64);
}
extern "C" {
    pub fn ggml_opt_prepare_alloc(
        opt_ctx: ggml_opt_context_t,
        ctx_compute: *mut ggml_context,
        gf: *mut ggml_cgraph,
        inputs: *mut ggml_tensor,
        outputs: *mut ggml_tensor,
    );
}
extern "C" {
    pub fn ggml_opt_alloc(opt_ctx: ggml_opt_context_t, backward: bool);
}
extern "C" {
    pub fn ggml_opt_eval(opt_ctx: ggml_opt_context_t, result: ggml_opt_result_t);
}
pub type ggml_opt_epoch_callback = ::std::option::Option<
    unsafe extern "C" fn(
        train: bool,
        opt_ctx: ggml_opt_context_t,
        dataset: ggml_opt_dataset_t,
        result: ggml_opt_result_t,
        ibatch: i64,
        ibatch_max: i64,
        t_start_us: i64,
    ),
>;
extern "C" {
    pub fn ggml_opt_epoch(
        opt_ctx: ggml_opt_context_t,
        dataset: ggml_opt_dataset_t,
        result_train: ggml_opt_result_t,
        result_eval: ggml_opt_result_t,
        idata_split: i64,
        callback_train: ggml_opt_epoch_callback,
        callback_eval: ggml_opt_epoch_callback,
    );
}
extern "C" {
    pub fn ggml_opt_epoch_callback_progress_bar(
        train: bool,
        opt_ctx: ggml_opt_context_t,
        dataset: ggml_opt_dataset_t,
        result: ggml_opt_result_t,
        ibatch: i64,
        ibatch_max: i64,
        t_start_us: i64,
    );
}
extern "C" {
    pub fn ggml_opt_fit(
        backend_sched: ggml_backend_sched_t,
        ctx_compute: *mut ggml_context,
        inputs: *mut ggml_tensor,
        outputs: *mut ggml_tensor,
        dataset: ggml_opt_dataset_t,
        loss_type: ggml_opt_loss_type,
        optimizer: ggml_opt_optimizer_type,
        get_opt_pars: ggml_opt_get_optimizer_params,
        nepoch: i64,
        nbatch_logical: i64,
        val_split: f32,
        silent: bool,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_vocab {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_model {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_memory_i {
    _unused: [u8; 0],
}
pub type llama_memory_t = *mut llama_memory_i;
pub type llama_pos = i32;
pub type llama_token = i32;
pub type llama_seq_id = i32;
pub const llama_vocab_type_LLAMA_VOCAB_TYPE_NONE: llama_vocab_type = 0;
pub const llama_vocab_type_LLAMA_VOCAB_TYPE_SPM: llama_vocab_type = 1;
pub const llama_vocab_type_LLAMA_VOCAB_TYPE_BPE: llama_vocab_type = 2;
pub const llama_vocab_type_LLAMA_VOCAB_TYPE_WPM: llama_vocab_type = 3;
pub const llama_vocab_type_LLAMA_VOCAB_TYPE_UGM: llama_vocab_type = 4;
pub const llama_vocab_type_LLAMA_VOCAB_TYPE_RWKV: llama_vocab_type = 5;
pub const llama_vocab_type_LLAMA_VOCAB_TYPE_PLAMO2: llama_vocab_type = 6;
pub type llama_vocab_type = ::std::os::raw::c_uint;
pub const llama_rope_type_LLAMA_ROPE_TYPE_NONE: llama_rope_type = -1;
pub const llama_rope_type_LLAMA_ROPE_TYPE_NORM: llama_rope_type = 0;
pub const llama_rope_type_LLAMA_ROPE_TYPE_NEOX: llama_rope_type = 2;
pub const llama_rope_type_LLAMA_ROPE_TYPE_MROPE: llama_rope_type = 8;
pub const llama_rope_type_LLAMA_ROPE_TYPE_IMROPE: llama_rope_type = 40;
pub const llama_rope_type_LLAMA_ROPE_TYPE_VISION: llama_rope_type = 24;
pub type llama_rope_type = ::std::os::raw::c_int;
pub const llama_token_type_LLAMA_TOKEN_TYPE_UNDEFINED: llama_token_type = 0;
pub const llama_token_type_LLAMA_TOKEN_TYPE_NORMAL: llama_token_type = 1;
pub const llama_token_type_LLAMA_TOKEN_TYPE_UNKNOWN: llama_token_type = 2;
pub const llama_token_type_LLAMA_TOKEN_TYPE_CONTROL: llama_token_type = 3;
pub const llama_token_type_LLAMA_TOKEN_TYPE_USER_DEFINED: llama_token_type = 4;
pub const llama_token_type_LLAMA_TOKEN_TYPE_UNUSED: llama_token_type = 5;
pub const llama_token_type_LLAMA_TOKEN_TYPE_BYTE: llama_token_type = 6;
pub type llama_token_type = ::std::os::raw::c_uint;
pub const llama_token_attr_LLAMA_TOKEN_ATTR_UNDEFINED: llama_token_attr = 0;
pub const llama_token_attr_LLAMA_TOKEN_ATTR_UNKNOWN: llama_token_attr = 1;
pub const llama_token_attr_LLAMA_TOKEN_ATTR_UNUSED: llama_token_attr = 2;
pub const llama_token_attr_LLAMA_TOKEN_ATTR_NORMAL: llama_token_attr = 4;
pub const llama_token_attr_LLAMA_TOKEN_ATTR_CONTROL: llama_token_attr = 8;
pub const llama_token_attr_LLAMA_TOKEN_ATTR_USER_DEFINED: llama_token_attr = 16;
pub const llama_token_attr_LLAMA_TOKEN_ATTR_BYTE: llama_token_attr = 32;
pub const llama_token_attr_LLAMA_TOKEN_ATTR_NORMALIZED: llama_token_attr = 64;
pub const llama_token_attr_LLAMA_TOKEN_ATTR_LSTRIP: llama_token_attr = 128;
pub const llama_token_attr_LLAMA_TOKEN_ATTR_RSTRIP: llama_token_attr = 256;
pub const llama_token_attr_LLAMA_TOKEN_ATTR_SINGLE_WORD: llama_token_attr = 512;
pub type llama_token_attr = ::std::os::raw::c_uint;
pub const llama_ftype_LLAMA_FTYPE_ALL_F32: llama_ftype = 0;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_F16: llama_ftype = 1;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_Q4_0: llama_ftype = 2;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_Q4_1: llama_ftype = 3;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_Q8_0: llama_ftype = 7;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_Q5_0: llama_ftype = 8;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_Q5_1: llama_ftype = 9;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_Q2_K: llama_ftype = 10;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_Q3_K_S: llama_ftype = 11;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_Q3_K_M: llama_ftype = 12;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_Q3_K_L: llama_ftype = 13;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_Q4_K_S: llama_ftype = 14;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_Q4_K_M: llama_ftype = 15;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_Q5_K_S: llama_ftype = 16;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_Q5_K_M: llama_ftype = 17;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_Q6_K: llama_ftype = 18;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_IQ2_XXS: llama_ftype = 19;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_IQ2_XS: llama_ftype = 20;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_Q2_K_S: llama_ftype = 21;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_IQ3_XS: llama_ftype = 22;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_IQ3_XXS: llama_ftype = 23;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_IQ1_S: llama_ftype = 24;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_IQ4_NL: llama_ftype = 25;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_IQ3_S: llama_ftype = 26;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_IQ3_M: llama_ftype = 27;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_IQ2_S: llama_ftype = 28;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_IQ2_M: llama_ftype = 29;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_IQ4_XS: llama_ftype = 30;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_IQ1_M: llama_ftype = 31;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_BF16: llama_ftype = 32;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_TQ1_0: llama_ftype = 36;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_TQ2_0: llama_ftype = 37;
pub const llama_ftype_LLAMA_FTYPE_MOSTLY_MXFP4_MOE: llama_ftype = 38;
pub const llama_ftype_LLAMA_FTYPE_GUESSED: llama_ftype = 1024;
pub type llama_ftype = ::std::os::raw::c_uint;
pub const llama_rope_scaling_type_LLAMA_ROPE_SCALING_TYPE_UNSPECIFIED: llama_rope_scaling_type = -1;
pub const llama_rope_scaling_type_LLAMA_ROPE_SCALING_TYPE_NONE: llama_rope_scaling_type = 0;
pub const llama_rope_scaling_type_LLAMA_ROPE_SCALING_TYPE_LINEAR: llama_rope_scaling_type = 1;
pub const llama_rope_scaling_type_LLAMA_ROPE_SCALING_TYPE_YARN: llama_rope_scaling_type = 2;
pub const llama_rope_scaling_type_LLAMA_ROPE_SCALING_TYPE_LONGROPE: llama_rope_scaling_type = 3;
pub const llama_rope_scaling_type_LLAMA_ROPE_SCALING_TYPE_MAX_VALUE: llama_rope_scaling_type = 3;
pub type llama_rope_scaling_type = ::std::os::raw::c_int;
pub const llama_pooling_type_LLAMA_POOLING_TYPE_UNSPECIFIED: llama_pooling_type = -1;
pub const llama_pooling_type_LLAMA_POOLING_TYPE_NONE: llama_pooling_type = 0;
pub const llama_pooling_type_LLAMA_POOLING_TYPE_MEAN: llama_pooling_type = 1;
pub const llama_pooling_type_LLAMA_POOLING_TYPE_CLS: llama_pooling_type = 2;
pub const llama_pooling_type_LLAMA_POOLING_TYPE_LAST: llama_pooling_type = 3;
pub const llama_pooling_type_LLAMA_POOLING_TYPE_RANK: llama_pooling_type = 4;
pub type llama_pooling_type = ::std::os::raw::c_int;
pub const llama_attention_type_LLAMA_ATTENTION_TYPE_UNSPECIFIED: llama_attention_type = -1;
pub const llama_attention_type_LLAMA_ATTENTION_TYPE_CAUSAL: llama_attention_type = 0;
pub const llama_attention_type_LLAMA_ATTENTION_TYPE_NON_CAUSAL: llama_attention_type = 1;
pub type llama_attention_type = ::std::os::raw::c_int;
pub const llama_flash_attn_type_LLAMA_FLASH_ATTN_TYPE_AUTO: llama_flash_attn_type = -1;
pub const llama_flash_attn_type_LLAMA_FLASH_ATTN_TYPE_DISABLED: llama_flash_attn_type = 0;
pub const llama_flash_attn_type_LLAMA_FLASH_ATTN_TYPE_ENABLED: llama_flash_attn_type = 1;
pub type llama_flash_attn_type = ::std::os::raw::c_int;
extern "C" {
    pub fn llama_flash_attn_type_name(
        flash_attn_type: llama_flash_attn_type,
    ) -> *const ::std::os::raw::c_char;
}
pub const llama_split_mode_LLAMA_SPLIT_MODE_NONE: llama_split_mode = 0;
pub const llama_split_mode_LLAMA_SPLIT_MODE_LAYER: llama_split_mode = 1;
pub const llama_split_mode_LLAMA_SPLIT_MODE_ROW: llama_split_mode = 2;
pub type llama_split_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_token_data {
    pub id: llama_token,
    pub logit: f32,
    pub p: f32,
}
#[test]
fn bindgen_test_layout_llama_token_data() {
    const UNINIT: ::std::mem::MaybeUninit<llama_token_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_token_data>(),
        12usize,
        concat!("Size of: ", stringify!(llama_token_data))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_token_data>(),
        4usize,
        concat!("Alignment of ", stringify!(llama_token_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_token_data),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logit) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_token_data),
            "::",
            stringify!(logit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_token_data),
            "::",
            stringify!(p)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_token_data_array {
    pub data: *mut llama_token_data,
    pub size: usize,
    pub selected: i64,
    pub sorted: bool,
}
#[test]
fn bindgen_test_layout_llama_token_data_array() {
    const UNINIT: ::std::mem::MaybeUninit<llama_token_data_array> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_token_data_array>(),
        32usize,
        concat!("Size of: ", stringify!(llama_token_data_array))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_token_data_array>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_token_data_array))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_token_data_array),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_token_data_array),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).selected) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_token_data_array),
            "::",
            stringify!(selected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sorted) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_token_data_array),
            "::",
            stringify!(sorted)
        )
    );
}
pub type llama_progress_callback = ::std::option::Option<
    unsafe extern "C" fn(progress: f32, user_data: *mut ::std::os::raw::c_void) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_batch {
    pub n_tokens: i32,
    pub token: *mut llama_token,
    pub embd: *mut f32,
    pub pos: *mut llama_pos,
    pub n_seq_id: *mut i32,
    pub seq_id: *mut *mut llama_seq_id,
    pub logits: *mut i8,
}
#[test]
fn bindgen_test_layout_llama_batch() {
    const UNINIT: ::std::mem::MaybeUninit<llama_batch> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_batch>(),
        56usize,
        concat!("Size of: ", stringify!(llama_batch))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_batch>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_batch))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_tokens) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_batch),
            "::",
            stringify!(n_tokens)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_batch),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).embd) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_batch),
            "::",
            stringify!(embd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_batch),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_seq_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_batch),
            "::",
            stringify!(n_seq_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_batch),
            "::",
            stringify!(seq_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logits) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_batch),
            "::",
            stringify!(logits)
        )
    );
}
pub const llama_model_kv_override_type_LLAMA_KV_OVERRIDE_TYPE_INT: llama_model_kv_override_type = 0;
pub const llama_model_kv_override_type_LLAMA_KV_OVERRIDE_TYPE_FLOAT: llama_model_kv_override_type =
    1;
pub const llama_model_kv_override_type_LLAMA_KV_OVERRIDE_TYPE_BOOL: llama_model_kv_override_type =
    2;
pub const llama_model_kv_override_type_LLAMA_KV_OVERRIDE_TYPE_STR: llama_model_kv_override_type = 3;
pub type llama_model_kv_override_type = ::std::os::raw::c_uint;
pub const llama_model_meta_key_LLAMA_MODEL_META_KEY_SAMPLING_SEQUENCE: llama_model_meta_key = 0;
pub const llama_model_meta_key_LLAMA_MODEL_META_KEY_SAMPLING_TOP_K: llama_model_meta_key = 1;
pub const llama_model_meta_key_LLAMA_MODEL_META_KEY_SAMPLING_TOP_P: llama_model_meta_key = 2;
pub const llama_model_meta_key_LLAMA_MODEL_META_KEY_SAMPLING_MIN_P: llama_model_meta_key = 3;
pub const llama_model_meta_key_LLAMA_MODEL_META_KEY_SAMPLING_XTC_PROBABILITY: llama_model_meta_key =
    4;
pub const llama_model_meta_key_LLAMA_MODEL_META_KEY_SAMPLING_XTC_THRESHOLD: llama_model_meta_key =
    5;
pub const llama_model_meta_key_LLAMA_MODEL_META_KEY_SAMPLING_TEMP: llama_model_meta_key = 6;
pub const llama_model_meta_key_LLAMA_MODEL_META_KEY_SAMPLING_PENALTY_LAST_N: llama_model_meta_key =
    7;
pub const llama_model_meta_key_LLAMA_MODEL_META_KEY_SAMPLING_PENALTY_REPEAT: llama_model_meta_key =
    8;
pub const llama_model_meta_key_LLAMA_MODEL_META_KEY_SAMPLING_MIROSTAT: llama_model_meta_key = 9;
pub const llama_model_meta_key_LLAMA_MODEL_META_KEY_SAMPLING_MIROSTAT_TAU: llama_model_meta_key =
    10;
pub const llama_model_meta_key_LLAMA_MODEL_META_KEY_SAMPLING_MIROSTAT_ETA: llama_model_meta_key =
    11;
pub type llama_model_meta_key = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct llama_model_kv_override {
    pub tag: llama_model_kv_override_type,
    pub key: [::std::os::raw::c_char; 128usize],
    pub __bindgen_anon_1: llama_model_kv_override__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union llama_model_kv_override__bindgen_ty_1 {
    pub val_i64: i64,
    pub val_f64: f64,
    pub val_bool: bool,
    pub val_str: [::std::os::raw::c_char; 128usize],
}
#[test]
fn bindgen_test_layout_llama_model_kv_override__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<llama_model_kv_override__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_model_kv_override__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(llama_model_kv_override__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<llama_model_kv_override__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(llama_model_kv_override__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val_i64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_kv_override__bindgen_ty_1),
            "::",
            stringify!(val_i64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val_f64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_kv_override__bindgen_ty_1),
            "::",
            stringify!(val_f64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val_bool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_kv_override__bindgen_ty_1),
            "::",
            stringify!(val_bool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val_str) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_kv_override__bindgen_ty_1),
            "::",
            stringify!(val_str)
        )
    );
}
#[test]
fn bindgen_test_layout_llama_model_kv_override() {
    const UNINIT: ::std::mem::MaybeUninit<llama_model_kv_override> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_model_kv_override>(),
        264usize,
        concat!("Size of: ", stringify!(llama_model_kv_override))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_model_kv_override>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_model_kv_override))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_kv_override),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_kv_override),
            "::",
            stringify!(key)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_model_tensor_buft_override {
    pub pattern: *const ::std::os::raw::c_char,
    pub buft: ggml_backend_buffer_type_t,
}
#[test]
fn bindgen_test_layout_llama_model_tensor_buft_override() {
    const UNINIT: ::std::mem::MaybeUninit<llama_model_tensor_buft_override> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_model_tensor_buft_override>(),
        16usize,
        concat!("Size of: ", stringify!(llama_model_tensor_buft_override))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_model_tensor_buft_override>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(llama_model_tensor_buft_override)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pattern) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_tensor_buft_override),
            "::",
            stringify!(pattern)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buft) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_tensor_buft_override),
            "::",
            stringify!(buft)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_model_params {
    pub devices: *mut ggml_backend_dev_t,
    pub tensor_buft_overrides: *const llama_model_tensor_buft_override,
    pub n_gpu_layers: i32,
    pub split_mode: llama_split_mode,
    pub main_gpu: i32,
    pub tensor_split: *const f32,
    pub progress_callback: llama_progress_callback,
    pub progress_callback_user_data: *mut ::std::os::raw::c_void,
    pub kv_overrides: *const llama_model_kv_override,
    pub vocab_only: bool,
    pub use_mmap: bool,
    pub use_direct_io: bool,
    pub use_mlock: bool,
    pub check_tensors: bool,
    pub use_extra_bufts: bool,
    pub no_host: bool,
    pub no_alloc: bool,
}
#[test]
fn bindgen_test_layout_llama_model_params() {
    const UNINIT: ::std::mem::MaybeUninit<llama_model_params> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_model_params>(),
        72usize,
        concat!("Size of: ", stringify!(llama_model_params))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_model_params>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_model_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).devices) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(devices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tensor_buft_overrides) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(tensor_buft_overrides)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_gpu_layers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(n_gpu_layers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).split_mode) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(split_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).main_gpu) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(main_gpu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tensor_split) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(tensor_split)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).progress_callback) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(progress_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).progress_callback_user_data) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(progress_callback_user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kv_overrides) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(kv_overrides)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vocab_only) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(vocab_only)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_mmap) as usize - ptr as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(use_mmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_direct_io) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(use_direct_io)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_mlock) as usize - ptr as usize },
        67usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(use_mlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).check_tensors) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(check_tensors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_extra_bufts) as usize - ptr as usize },
        69usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(use_extra_bufts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no_host) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(no_host)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no_alloc) as usize - ptr as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_params),
            "::",
            stringify!(no_alloc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_sampler_seq_config {
    pub seq_id: llama_seq_id,
    pub sampler: *mut llama_sampler,
}
#[test]
fn bindgen_test_layout_llama_sampler_seq_config() {
    const UNINIT: ::std::mem::MaybeUninit<llama_sampler_seq_config> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_sampler_seq_config>(),
        16usize,
        concat!("Size of: ", stringify!(llama_sampler_seq_config))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_sampler_seq_config>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_sampler_seq_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_seq_config),
            "::",
            stringify!(seq_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sampler) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_seq_config),
            "::",
            stringify!(sampler)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_context_params {
    pub n_ctx: u32,
    pub n_batch: u32,
    pub n_ubatch: u32,
    pub n_seq_max: u32,
    pub n_threads: i32,
    pub n_threads_batch: i32,
    pub rope_scaling_type: llama_rope_scaling_type,
    pub pooling_type: llama_pooling_type,
    pub attention_type: llama_attention_type,
    pub flash_attn_type: llama_flash_attn_type,
    pub rope_freq_base: f32,
    pub rope_freq_scale: f32,
    pub yarn_ext_factor: f32,
    pub yarn_attn_factor: f32,
    pub yarn_beta_fast: f32,
    pub yarn_beta_slow: f32,
    pub yarn_orig_ctx: u32,
    pub defrag_thold: f32,
    pub cb_eval: ggml_backend_sched_eval_callback,
    pub cb_eval_user_data: *mut ::std::os::raw::c_void,
    pub type_k: ggml_type,
    pub type_v: ggml_type,
    pub abort_callback: ggml_abort_callback,
    pub abort_callback_data: *mut ::std::os::raw::c_void,
    pub embeddings: bool,
    pub offload_kqv: bool,
    pub no_perf: bool,
    pub op_offload: bool,
    pub swa_full: bool,
    pub kv_unified: bool,
    pub samplers: *mut llama_sampler_seq_config,
    pub n_samplers: usize,
}
#[test]
fn bindgen_test_layout_llama_context_params() {
    const UNINIT: ::std::mem::MaybeUninit<llama_context_params> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_context_params>(),
        136usize,
        concat!("Size of: ", stringify!(llama_context_params))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_context_params>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_context_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(n_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_batch) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(n_batch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_ubatch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(n_ubatch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_seq_max) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(n_seq_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_threads) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(n_threads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_threads_batch) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(n_threads_batch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rope_scaling_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(rope_scaling_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pooling_type) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(pooling_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attention_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(attention_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flash_attn_type) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(flash_attn_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rope_freq_base) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(rope_freq_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rope_freq_scale) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(rope_freq_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yarn_ext_factor) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(yarn_ext_factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yarn_attn_factor) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(yarn_attn_factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yarn_beta_fast) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(yarn_beta_fast)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yarn_beta_slow) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(yarn_beta_slow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yarn_orig_ctx) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(yarn_orig_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defrag_thold) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(defrag_thold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb_eval) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(cb_eval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb_eval_user_data) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(cb_eval_user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_k) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(type_k)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_v) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(type_v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abort_callback) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(abort_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abort_callback_data) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(abort_callback_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).embeddings) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(embeddings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offload_kqv) as usize - ptr as usize },
        113usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(offload_kqv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no_perf) as usize - ptr as usize },
        114usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(no_perf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).op_offload) as usize - ptr as usize },
        115usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(op_offload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swa_full) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(swa_full)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kv_unified) as usize - ptr as usize },
        117usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(kv_unified)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samplers) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(samplers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_samplers) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_context_params),
            "::",
            stringify!(n_samplers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_model_quantize_params {
    pub nthread: i32,
    pub ftype: llama_ftype,
    pub output_tensor_type: ggml_type,
    pub token_embedding_type: ggml_type,
    pub allow_requantize: bool,
    pub quantize_output_tensor: bool,
    pub only_copy: bool,
    pub pure_: bool,
    pub keep_split: bool,
    pub imatrix: *mut ::std::os::raw::c_void,
    pub kv_overrides: *mut ::std::os::raw::c_void,
    pub tensor_types: *mut ::std::os::raw::c_void,
    pub prune_layers: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_llama_model_quantize_params() {
    const UNINIT: ::std::mem::MaybeUninit<llama_model_quantize_params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_model_quantize_params>(),
        56usize,
        concat!("Size of: ", stringify!(llama_model_quantize_params))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_model_quantize_params>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_model_quantize_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nthread) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(nthread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ftype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(ftype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_tensor_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(output_tensor_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).token_embedding_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(token_embedding_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allow_requantize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(allow_requantize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quantize_output_tensor) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(quantize_output_tensor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).only_copy) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(only_copy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pure_) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(pure_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keep_split) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(keep_split)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imatrix) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(imatrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kv_overrides) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(kv_overrides)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tensor_types) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(tensor_types)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prune_layers) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_model_quantize_params),
            "::",
            stringify!(prune_layers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_logit_bias {
    pub token: llama_token,
    pub bias: f32,
}
#[test]
fn bindgen_test_layout_llama_logit_bias() {
    const UNINIT: ::std::mem::MaybeUninit<llama_logit_bias> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_logit_bias>(),
        8usize,
        concat!("Size of: ", stringify!(llama_logit_bias))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_logit_bias>(),
        4usize,
        concat!("Alignment of ", stringify!(llama_logit_bias))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_logit_bias),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bias) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_logit_bias),
            "::",
            stringify!(bias)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_sampler_chain_params {
    pub no_perf: bool,
}
#[test]
fn bindgen_test_layout_llama_sampler_chain_params() {
    const UNINIT: ::std::mem::MaybeUninit<llama_sampler_chain_params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_sampler_chain_params>(),
        1usize,
        concat!("Size of: ", stringify!(llama_sampler_chain_params))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_sampler_chain_params>(),
        1usize,
        concat!("Alignment of ", stringify!(llama_sampler_chain_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no_perf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_chain_params),
            "::",
            stringify!(no_perf)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_chat_message {
    pub role: *const ::std::os::raw::c_char,
    pub content: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_llama_chat_message() {
    const UNINIT: ::std::mem::MaybeUninit<llama_chat_message> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_chat_message>(),
        16usize,
        concat!("Size of: ", stringify!(llama_chat_message))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_chat_message>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_chat_message))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).role) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_chat_message),
            "::",
            stringify!(role)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_chat_message),
            "::",
            stringify!(content)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_adapter_lora {
    _unused: [u8; 0],
}
extern "C" {
    pub fn llama_model_default_params() -> llama_model_params;
}
extern "C" {
    pub fn llama_context_default_params() -> llama_context_params;
}
extern "C" {
    pub fn llama_sampler_chain_default_params() -> llama_sampler_chain_params;
}
extern "C" {
    pub fn llama_model_quantize_default_params() -> llama_model_quantize_params;
}
extern "C" {
    pub fn llama_backend_init();
}
extern "C" {
    pub fn llama_backend_free();
}
extern "C" {
    pub fn llama_numa_init(numa: ggml_numa_strategy);
}
extern "C" {
    pub fn llama_attach_threadpool(
        ctx: *mut llama_context,
        threadpool: ggml_threadpool_t,
        threadpool_batch: ggml_threadpool_t,
    );
}
extern "C" {
    pub fn llama_detach_threadpool(ctx: *mut llama_context);
}
extern "C" {
    pub fn llama_load_model_from_file(
        path_model: *const ::std::os::raw::c_char,
        params: llama_model_params,
    ) -> *mut llama_model;
}
extern "C" {
    pub fn llama_model_load_from_file(
        path_model: *const ::std::os::raw::c_char,
        params: llama_model_params,
    ) -> *mut llama_model;
}
extern "C" {
    pub fn llama_model_load_from_splits(
        paths: *mut *const ::std::os::raw::c_char,
        n_paths: usize,
        params: llama_model_params,
    ) -> *mut llama_model;
}
extern "C" {
    pub fn llama_model_save_to_file(
        model: *const llama_model,
        path_model: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn llama_free_model(model: *mut llama_model);
}
extern "C" {
    pub fn llama_model_free(model: *mut llama_model);
}
extern "C" {
    pub fn llama_init_from_model(
        model: *mut llama_model,
        params: llama_context_params,
    ) -> *mut llama_context;
}
extern "C" {
    pub fn llama_new_context_with_model(
        model: *mut llama_model,
        params: llama_context_params,
    ) -> *mut llama_context;
}
extern "C" {
    pub fn llama_free(ctx: *mut llama_context);
}
pub const llama_params_fit_status_LLAMA_PARAMS_FIT_STATUS_SUCCESS: llama_params_fit_status = 0;
pub const llama_params_fit_status_LLAMA_PARAMS_FIT_STATUS_FAILURE: llama_params_fit_status = 1;
pub const llama_params_fit_status_LLAMA_PARAMS_FIT_STATUS_ERROR: llama_params_fit_status = 2;
pub type llama_params_fit_status = ::std::os::raw::c_uint;
extern "C" {
    pub fn llama_params_fit(
        path_model: *const ::std::os::raw::c_char,
        mparams: *mut llama_model_params,
        cparams: *mut llama_context_params,
        tensor_split: *mut f32,
        tensor_buft_overrides: *mut llama_model_tensor_buft_override,
        margins: *mut usize,
        n_ctx_min: u32,
        log_level: ggml_log_level,
    ) -> llama_params_fit_status;
}
extern "C" {
    pub fn llama_time_us() -> i64;
}
extern "C" {
    pub fn llama_max_devices() -> usize;
}
extern "C" {
    pub fn llama_max_parallel_sequences() -> usize;
}
extern "C" {
    pub fn llama_max_tensor_buft_overrides() -> usize;
}
extern "C" {
    pub fn llama_supports_mmap() -> bool;
}
extern "C" {
    pub fn llama_supports_mlock() -> bool;
}
extern "C" {
    pub fn llama_supports_gpu_offload() -> bool;
}
extern "C" {
    pub fn llama_supports_rpc() -> bool;
}
extern "C" {
    pub fn llama_n_ctx(ctx: *const llama_context) -> u32;
}
extern "C" {
    pub fn llama_n_ctx_seq(ctx: *const llama_context) -> u32;
}
extern "C" {
    pub fn llama_n_batch(ctx: *const llama_context) -> u32;
}
extern "C" {
    pub fn llama_n_ubatch(ctx: *const llama_context) -> u32;
}
extern "C" {
    pub fn llama_n_seq_max(ctx: *const llama_context) -> u32;
}
extern "C" {
    pub fn llama_n_ctx_train(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_n_embd(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_n_layer(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_n_head(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_n_vocab(vocab: *const llama_vocab) -> i32;
}
extern "C" {
    pub fn llama_get_model(ctx: *const llama_context) -> *const llama_model;
}
extern "C" {
    pub fn llama_get_memory(ctx: *const llama_context) -> llama_memory_t;
}
extern "C" {
    pub fn llama_pooling_type(ctx: *const llama_context) -> llama_pooling_type;
}
extern "C" {
    pub fn llama_model_get_vocab(model: *const llama_model) -> *const llama_vocab;
}
extern "C" {
    pub fn llama_model_rope_type(model: *const llama_model) -> llama_rope_type;
}
extern "C" {
    pub fn llama_model_n_ctx_train(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_model_n_embd(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_model_n_embd_inp(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_model_n_embd_out(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_model_n_layer(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_model_n_head(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_model_n_head_kv(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_model_n_swa(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_model_rope_freq_scale_train(model: *const llama_model) -> f32;
}
extern "C" {
    pub fn llama_model_n_cls_out(model: *const llama_model) -> u32;
}
extern "C" {
    pub fn llama_model_cls_label(
        model: *const llama_model,
        i: u32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn llama_vocab_type(vocab: *const llama_vocab) -> llama_vocab_type;
}
extern "C" {
    pub fn llama_vocab_n_tokens(vocab: *const llama_vocab) -> i32;
}
extern "C" {
    pub fn llama_model_meta_val_str(
        model: *const llama_model,
        key: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
    ) -> i32;
}
extern "C" {
    pub fn llama_model_meta_count(model: *const llama_model) -> i32;
}
extern "C" {
    pub fn llama_model_meta_key_str(key: llama_model_meta_key) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn llama_model_meta_key_by_index(
        model: *const llama_model,
        i: i32,
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
    ) -> i32;
}
extern "C" {
    pub fn llama_model_meta_val_str_by_index(
        model: *const llama_model,
        i: i32,
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
    ) -> i32;
}
extern "C" {
    pub fn llama_model_desc(
        model: *const llama_model,
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
    ) -> i32;
}
extern "C" {
    pub fn llama_model_size(model: *const llama_model) -> u64;
}
extern "C" {
    pub fn llama_model_chat_template(
        model: *const llama_model,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn llama_model_n_params(model: *const llama_model) -> u64;
}
extern "C" {
    pub fn llama_model_has_encoder(model: *const llama_model) -> bool;
}
extern "C" {
    pub fn llama_model_has_decoder(model: *const llama_model) -> bool;
}
extern "C" {
    pub fn llama_model_decoder_start_token(model: *const llama_model) -> llama_token;
}
extern "C" {
    pub fn llama_model_is_recurrent(model: *const llama_model) -> bool;
}
extern "C" {
    pub fn llama_model_is_hybrid(model: *const llama_model) -> bool;
}
extern "C" {
    pub fn llama_model_is_diffusion(model: *const llama_model) -> bool;
}
extern "C" {
    pub fn llama_model_quantize(
        fname_inp: *const ::std::os::raw::c_char,
        fname_out: *const ::std::os::raw::c_char,
        params: *const llama_model_quantize_params,
    ) -> u32;
}
extern "C" {
    pub fn llama_adapter_lora_init(
        model: *mut llama_model,
        path_lora: *const ::std::os::raw::c_char,
    ) -> *mut llama_adapter_lora;
}
extern "C" {
    pub fn llama_adapter_meta_val_str(
        adapter: *const llama_adapter_lora,
        key: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
    ) -> i32;
}
extern "C" {
    pub fn llama_adapter_meta_count(adapter: *const llama_adapter_lora) -> i32;
}
extern "C" {
    pub fn llama_adapter_meta_key_by_index(
        adapter: *const llama_adapter_lora,
        i: i32,
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
    ) -> i32;
}
extern "C" {
    pub fn llama_adapter_meta_val_str_by_index(
        adapter: *const llama_adapter_lora,
        i: i32,
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
    ) -> i32;
}
extern "C" {
    pub fn llama_adapter_lora_free(adapter: *mut llama_adapter_lora);
}
extern "C" {
    pub fn llama_adapter_get_alora_n_invocation_tokens(adapter: *const llama_adapter_lora) -> u64;
}
extern "C" {
    pub fn llama_adapter_get_alora_invocation_tokens(
        adapter: *const llama_adapter_lora,
    ) -> *const llama_token;
}
extern "C" {
    pub fn llama_set_adapter_lora(
        ctx: *mut llama_context,
        adapter: *mut llama_adapter_lora,
        scale: f32,
    ) -> i32;
}
extern "C" {
    pub fn llama_rm_adapter_lora(ctx: *mut llama_context, adapter: *mut llama_adapter_lora) -> i32;
}
extern "C" {
    pub fn llama_clear_adapter_lora(ctx: *mut llama_context);
}
extern "C" {
    pub fn llama_apply_adapter_cvec(
        ctx: *mut llama_context,
        data: *const f32,
        len: usize,
        n_embd: i32,
        il_start: i32,
        il_end: i32,
    ) -> i32;
}
extern "C" {
    pub fn llama_memory_clear(mem: llama_memory_t, data: bool);
}
extern "C" {
    pub fn llama_memory_seq_rm(
        mem: llama_memory_t,
        seq_id: llama_seq_id,
        p0: llama_pos,
        p1: llama_pos,
    ) -> bool;
}
extern "C" {
    pub fn llama_memory_seq_cp(
        mem: llama_memory_t,
        seq_id_src: llama_seq_id,
        seq_id_dst: llama_seq_id,
        p0: llama_pos,
        p1: llama_pos,
    );
}
extern "C" {
    pub fn llama_memory_seq_keep(mem: llama_memory_t, seq_id: llama_seq_id);
}
extern "C" {
    pub fn llama_memory_seq_add(
        mem: llama_memory_t,
        seq_id: llama_seq_id,
        p0: llama_pos,
        p1: llama_pos,
        delta: llama_pos,
    );
}
extern "C" {
    pub fn llama_memory_seq_div(
        mem: llama_memory_t,
        seq_id: llama_seq_id,
        p0: llama_pos,
        p1: llama_pos,
        d: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn llama_memory_seq_pos_min(mem: llama_memory_t, seq_id: llama_seq_id) -> llama_pos;
}
extern "C" {
    pub fn llama_memory_seq_pos_max(mem: llama_memory_t, seq_id: llama_seq_id) -> llama_pos;
}
extern "C" {
    pub fn llama_memory_can_shift(mem: llama_memory_t) -> bool;
}
extern "C" {
    pub fn llama_state_get_size(ctx: *mut llama_context) -> usize;
}
extern "C" {
    pub fn llama_get_state_size(ctx: *mut llama_context) -> usize;
}
extern "C" {
    pub fn llama_state_get_data(ctx: *mut llama_context, dst: *mut u8, size: usize) -> usize;
}
extern "C" {
    pub fn llama_copy_state_data(ctx: *mut llama_context, dst: *mut u8) -> usize;
}
extern "C" {
    pub fn llama_state_set_data(ctx: *mut llama_context, src: *const u8, size: usize) -> usize;
}
extern "C" {
    pub fn llama_set_state_data(ctx: *mut llama_context, src: *const u8) -> usize;
}
extern "C" {
    pub fn llama_state_load_file(
        ctx: *mut llama_context,
        path_session: *const ::std::os::raw::c_char,
        tokens_out: *mut llama_token,
        n_token_capacity: usize,
        n_token_count_out: *mut usize,
    ) -> bool;
}
extern "C" {
    pub fn llama_load_session_file(
        ctx: *mut llama_context,
        path_session: *const ::std::os::raw::c_char,
        tokens_out: *mut llama_token,
        n_token_capacity: usize,
        n_token_count_out: *mut usize,
    ) -> bool;
}
extern "C" {
    pub fn llama_state_save_file(
        ctx: *mut llama_context,
        path_session: *const ::std::os::raw::c_char,
        tokens: *const llama_token,
        n_token_count: usize,
    ) -> bool;
}
extern "C" {
    pub fn llama_save_session_file(
        ctx: *mut llama_context,
        path_session: *const ::std::os::raw::c_char,
        tokens: *const llama_token,
        n_token_count: usize,
    ) -> bool;
}
extern "C" {
    pub fn llama_state_seq_get_size(ctx: *mut llama_context, seq_id: llama_seq_id) -> usize;
}
extern "C" {
    pub fn llama_state_seq_get_data(
        ctx: *mut llama_context,
        dst: *mut u8,
        size: usize,
        seq_id: llama_seq_id,
    ) -> usize;
}
extern "C" {
    pub fn llama_state_seq_set_data(
        ctx: *mut llama_context,
        src: *const u8,
        size: usize,
        dest_seq_id: llama_seq_id,
    ) -> usize;
}
extern "C" {
    pub fn llama_state_seq_save_file(
        ctx: *mut llama_context,
        filepath: *const ::std::os::raw::c_char,
        seq_id: llama_seq_id,
        tokens: *const llama_token,
        n_token_count: usize,
    ) -> usize;
}
extern "C" {
    pub fn llama_state_seq_load_file(
        ctx: *mut llama_context,
        filepath: *const ::std::os::raw::c_char,
        dest_seq_id: llama_seq_id,
        tokens_out: *mut llama_token,
        n_token_capacity: usize,
        n_token_count_out: *mut usize,
    ) -> usize;
}
pub type llama_state_seq_flags = u32;
extern "C" {
    pub fn llama_state_seq_get_size_ext(
        ctx: *mut llama_context,
        seq_id: llama_seq_id,
        flags: llama_state_seq_flags,
    ) -> usize;
}
extern "C" {
    pub fn llama_state_seq_get_data_ext(
        ctx: *mut llama_context,
        dst: *mut u8,
        size: usize,
        seq_id: llama_seq_id,
        flags: llama_state_seq_flags,
    ) -> usize;
}
extern "C" {
    pub fn llama_state_seq_set_data_ext(
        ctx: *mut llama_context,
        src: *const u8,
        size: usize,
        dest_seq_id: llama_seq_id,
        flags: llama_state_seq_flags,
    ) -> usize;
}
extern "C" {
    pub fn llama_batch_get_one(tokens: *mut llama_token, n_tokens: i32) -> llama_batch;
}
extern "C" {
    pub fn llama_batch_init(n_tokens: i32, embd: i32, n_seq_max: i32) -> llama_batch;
}
extern "C" {
    pub fn llama_batch_free(batch: llama_batch);
}
extern "C" {
    pub fn llama_encode(ctx: *mut llama_context, batch: llama_batch) -> i32;
}
extern "C" {
    pub fn llama_decode(ctx: *mut llama_context, batch: llama_batch) -> i32;
}
extern "C" {
    pub fn llama_set_n_threads(ctx: *mut llama_context, n_threads: i32, n_threads_batch: i32);
}
extern "C" {
    pub fn llama_n_threads(ctx: *mut llama_context) -> i32;
}
extern "C" {
    pub fn llama_n_threads_batch(ctx: *mut llama_context) -> i32;
}
extern "C" {
    pub fn llama_set_embeddings(ctx: *mut llama_context, embeddings: bool);
}
extern "C" {
    pub fn llama_set_causal_attn(ctx: *mut llama_context, causal_attn: bool);
}
extern "C" {
    pub fn llama_set_warmup(ctx: *mut llama_context, warmup: bool);
}
extern "C" {
    pub fn llama_set_abort_callback(
        ctx: *mut llama_context,
        abort_callback: ggml_abort_callback,
        abort_callback_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn llama_synchronize(ctx: *mut llama_context);
}
extern "C" {
    pub fn llama_get_logits(ctx: *mut llama_context) -> *mut f32;
}
extern "C" {
    pub fn llama_get_logits_ith(ctx: *mut llama_context, i: i32) -> *mut f32;
}
extern "C" {
    pub fn llama_get_embeddings(ctx: *mut llama_context) -> *mut f32;
}
extern "C" {
    pub fn llama_get_embeddings_ith(ctx: *mut llama_context, i: i32) -> *mut f32;
}
extern "C" {
    pub fn llama_get_embeddings_seq(ctx: *mut llama_context, seq_id: llama_seq_id) -> *mut f32;
}
extern "C" {
    pub fn llama_get_sampled_token_ith(ctx: *mut llama_context, i: i32) -> llama_token;
}
extern "C" {
    pub fn llama_get_sampled_probs_ith(ctx: *mut llama_context, i: i32) -> *mut f32;
}
extern "C" {
    pub fn llama_get_sampled_probs_count_ith(ctx: *mut llama_context, i: i32) -> u32;
}
extern "C" {
    pub fn llama_get_sampled_logits_ith(ctx: *mut llama_context, i: i32) -> *mut f32;
}
extern "C" {
    pub fn llama_get_sampled_logits_count_ith(ctx: *mut llama_context, i: i32) -> u32;
}
extern "C" {
    pub fn llama_get_sampled_candidates_ith(ctx: *mut llama_context, i: i32) -> *mut llama_token;
}
extern "C" {
    pub fn llama_get_sampled_candidates_count_ith(ctx: *mut llama_context, i: i32) -> u32;
}
extern "C" {
    pub fn llama_vocab_get_text(
        vocab: *const llama_vocab,
        token: llama_token,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn llama_vocab_get_score(vocab: *const llama_vocab, token: llama_token) -> f32;
}
extern "C" {
    pub fn llama_vocab_get_attr(vocab: *const llama_vocab, token: llama_token) -> llama_token_attr;
}
extern "C" {
    pub fn llama_vocab_is_eog(vocab: *const llama_vocab, token: llama_token) -> bool;
}
extern "C" {
    pub fn llama_vocab_is_control(vocab: *const llama_vocab, token: llama_token) -> bool;
}
extern "C" {
    pub fn llama_vocab_bos(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_eos(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_eot(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_sep(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_nl(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_pad(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_mask(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_get_add_bos(vocab: *const llama_vocab) -> bool;
}
extern "C" {
    pub fn llama_vocab_get_add_eos(vocab: *const llama_vocab) -> bool;
}
extern "C" {
    pub fn llama_vocab_get_add_sep(vocab: *const llama_vocab) -> bool;
}
extern "C" {
    pub fn llama_vocab_fim_pre(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_fim_suf(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_fim_mid(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_fim_pad(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_fim_rep(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_fim_sep(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_get_text(
        vocab: *const llama_vocab,
        token: llama_token,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn llama_token_get_score(vocab: *const llama_vocab, token: llama_token) -> f32;
}
extern "C" {
    pub fn llama_token_get_attr(vocab: *const llama_vocab, token: llama_token) -> llama_token_attr;
}
extern "C" {
    pub fn llama_token_is_eog(vocab: *const llama_vocab, token: llama_token) -> bool;
}
extern "C" {
    pub fn llama_token_is_control(vocab: *const llama_vocab, token: llama_token) -> bool;
}
extern "C" {
    pub fn llama_token_bos(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_eos(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_eot(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_cls(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_sep(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_nl(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_pad(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_add_bos_token(vocab: *const llama_vocab) -> bool;
}
extern "C" {
    pub fn llama_add_eos_token(vocab: *const llama_vocab) -> bool;
}
extern "C" {
    pub fn llama_token_fim_pre(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_fim_suf(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_fim_mid(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_fim_pad(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_fim_rep(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_token_fim_sep(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    pub fn llama_vocab_cls(vocab: *const llama_vocab) -> llama_token;
}
extern "C" {
    #[doc = " @details Convert the provided text into tokens.\n @param tokens The tokens pointer must be large enough to hold the resulting tokens.\n @return Returns the number of tokens on success, no more than n_tokens_max\n @return Returns a negative number on failure - the number of tokens that would have been returned\n @return Returns INT32_MIN on overflow (e.g., tokenization result size exceeds int32_t limit)\n @param add_special Allow to add BOS and EOS tokens if model is configured to do so.\n @param parse_special Allow tokenizing special and/or control tokens which otherwise are not exposed and treated\n                      as plaintext. Does not insert a leading space."]
    pub fn llama_tokenize(
        vocab: *const llama_vocab,
        text: *const ::std::os::raw::c_char,
        text_len: i32,
        tokens: *mut llama_token,
        n_tokens_max: i32,
        add_special: bool,
        parse_special: bool,
    ) -> i32;
}
extern "C" {
    pub fn llama_token_to_piece(
        vocab: *const llama_vocab,
        token: llama_token,
        buf: *mut ::std::os::raw::c_char,
        length: i32,
        lstrip: i32,
        special: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " @details Convert the provided tokens into text (inverse of llama_tokenize()).\n @param text The char pointer must be large enough to hold the resulting text.\n @return Returns the number of chars/bytes on success, no more than text_len_max.\n @return Returns a negative number on failure - the number of chars/bytes that would have been returned.\n @param remove_special Allow to remove BOS and EOS tokens if model is configured to do so.\n @param unparse_special If true, special tokens are rendered in the output."]
    pub fn llama_detokenize(
        vocab: *const llama_vocab,
        tokens: *const llama_token,
        n_tokens: i32,
        text: *mut ::std::os::raw::c_char,
        text_len_max: i32,
        remove_special: bool,
        unparse_special: bool,
    ) -> i32;
}
extern "C" {
    #[doc = " Apply chat template. Inspired by hf apply_chat_template() on python.\n Both \"model\" and \"custom_template\" are optional, but at least one is required. \"custom_template\" has higher precedence than \"model\"\n NOTE: This function does not use a jinja parser. It only support a pre-defined list of template. See more: https://github.com/ggml-org/llama.cpp/wiki/Templates-supported-by-llama_chat_apply_template\n @param tmpl A Jinja template to use for this chat. If this is nullptr, the models default chat template will be used instead.\n @param chat Pointer to a list of multiple llama_chat_message\n @param n_msg Number of llama_chat_message in this chat\n @param add_ass Whether to end the prompt with the token(s) that indicate the start of an assistant message.\n @param buf A buffer to hold the output formatted prompt. The recommended alloc size is 2 * (total number of characters of all messages)\n @param length The size of the allocated buffer\n @return The total number of bytes of the formatted prompt. If is it larger than the size of buffer, you may need to re-alloc it and then re-apply the template."]
    pub fn llama_chat_apply_template(
        tmpl: *const ::std::os::raw::c_char,
        chat: *const llama_chat_message,
        n_msg: usize,
        add_ass: bool,
        buf: *mut ::std::os::raw::c_char,
        length: i32,
    ) -> i32;
}
extern "C" {
    pub fn llama_chat_builtin_templates(
        output: *mut *const ::std::os::raw::c_char,
        len: usize,
    ) -> i32;
}
pub type llama_sampler_context_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_sampler_data {
    pub logits: *mut ggml_tensor,
    pub probs: *mut ggml_tensor,
    pub sampled: *mut ggml_tensor,
    pub candidates: *mut ggml_tensor,
}
#[test]
fn bindgen_test_layout_llama_sampler_data() {
    const UNINIT: ::std::mem::MaybeUninit<llama_sampler_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_sampler_data>(),
        32usize,
        concat!("Size of: ", stringify!(llama_sampler_data))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_sampler_data>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_sampler_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_data),
            "::",
            stringify!(logits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).probs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_data),
            "::",
            stringify!(probs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sampled) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_data),
            "::",
            stringify!(sampled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).candidates) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_data),
            "::",
            stringify!(candidates)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_sampler_i {
    pub name: ::std::option::Option<
        unsafe extern "C" fn(smpl: *const llama_sampler) -> *const ::std::os::raw::c_char,
    >,
    pub accept:
        ::std::option::Option<unsafe extern "C" fn(smpl: *mut llama_sampler, token: llama_token)>,
    pub apply: ::std::option::Option<
        unsafe extern "C" fn(smpl: *mut llama_sampler, cur_p: *mut llama_token_data_array),
    >,
    pub reset: ::std::option::Option<unsafe extern "C" fn(smpl: *mut llama_sampler)>,
    pub clone: ::std::option::Option<
        unsafe extern "C" fn(smpl: *const llama_sampler) -> *mut llama_sampler,
    >,
    pub free: ::std::option::Option<unsafe extern "C" fn(smpl: *mut llama_sampler)>,
    pub backend_init: ::std::option::Option<
        unsafe extern "C" fn(smpl: *mut llama_sampler, buft: ggml_backend_buffer_type_t) -> bool,
    >,
    pub backend_accept: ::std::option::Option<
        unsafe extern "C" fn(
            smpl: *mut llama_sampler,
            ctx: *mut ggml_context,
            gf: *mut ggml_cgraph,
            selected_token: *mut ggml_tensor,
        ),
    >,
    pub backend_apply: ::std::option::Option<
        unsafe extern "C" fn(
            smpl: *mut llama_sampler,
            ctx: *mut ggml_context,
            gf: *mut ggml_cgraph,
            data: *mut llama_sampler_data,
        ),
    >,
    pub backend_set_input: ::std::option::Option<unsafe extern "C" fn(smpl: *mut llama_sampler)>,
}
#[test]
fn bindgen_test_layout_llama_sampler_i() {
    const UNINIT: ::std::mem::MaybeUninit<llama_sampler_i> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_sampler_i>(),
        80usize,
        concat!("Size of: ", stringify!(llama_sampler_i))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_sampler_i>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_sampler_i))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_i),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accept) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_i),
            "::",
            stringify!(accept)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apply) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_i),
            "::",
            stringify!(apply)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_i),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clone) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_i),
            "::",
            stringify!(clone)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_i),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backend_init) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_i),
            "::",
            stringify!(backend_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backend_accept) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_i),
            "::",
            stringify!(backend_accept)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backend_apply) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_i),
            "::",
            stringify!(backend_apply)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backend_set_input) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler_i),
            "::",
            stringify!(backend_set_input)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_sampler {
    pub iface: *mut llama_sampler_i,
    pub ctx: llama_sampler_context_t,
}
#[test]
fn bindgen_test_layout_llama_sampler() {
    const UNINIT: ::std::mem::MaybeUninit<llama_sampler> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_sampler>(),
        16usize,
        concat!("Size of: ", stringify!(llama_sampler))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_sampler>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_sampler))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler),
            "::",
            stringify!(iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_sampler),
            "::",
            stringify!(ctx)
        )
    );
}
extern "C" {
    pub fn llama_set_sampler(
        ctx: *mut llama_context,
        seq_id: llama_seq_id,
        smpl: *mut llama_sampler,
    ) -> bool;
}
extern "C" {
    pub fn llama_sampler_init(
        iface: *mut llama_sampler_i,
        ctx: llama_sampler_context_t,
    ) -> *mut llama_sampler;
}
extern "C" {
    pub fn llama_sampler_name(smpl: *const llama_sampler) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn llama_sampler_accept(smpl: *mut llama_sampler, token: llama_token);
}
extern "C" {
    pub fn llama_sampler_apply(smpl: *mut llama_sampler, cur_p: *mut llama_token_data_array);
}
extern "C" {
    pub fn llama_sampler_reset(smpl: *mut llama_sampler);
}
extern "C" {
    pub fn llama_sampler_clone(smpl: *const llama_sampler) -> *mut llama_sampler;
}
extern "C" {
    pub fn llama_sampler_free(smpl: *mut llama_sampler);
}
extern "C" {
    pub fn llama_sampler_chain_init(params: llama_sampler_chain_params) -> *mut llama_sampler;
}
extern "C" {
    pub fn llama_sampler_chain_add(chain: *mut llama_sampler, smpl: *mut llama_sampler);
}
extern "C" {
    pub fn llama_sampler_chain_get(chain: *mut llama_sampler, i: i32) -> *mut llama_sampler;
}
extern "C" {
    pub fn llama_sampler_chain_n(chain: *const llama_sampler) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn llama_sampler_chain_remove(chain: *mut llama_sampler, i: i32) -> *mut llama_sampler;
}
extern "C" {
    pub fn llama_sampler_init_greedy() -> *mut llama_sampler;
}
extern "C" {
    #[doc = " seed == LLAMA_DEFAULT_SEED to use a random seed."]
    pub fn llama_sampler_init_dist(seed: u32) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details Top-K sampling described in academic paper \"The Curious Case of Neural Text Degeneration\" https://arxiv.org/abs/1904.09751\n Setting k <= 0 makes this a noop"]
    pub fn llama_sampler_init_top_k(k: i32) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details Nucleus sampling described in academic paper \"The Curious Case of Neural Text Degeneration\" https://arxiv.org/abs/1904.09751"]
    pub fn llama_sampler_init_top_p(p: f32, min_keep: usize) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details Minimum P sampling as described in https://github.com/ggml-org/llama.cpp/pull/3841"]
    pub fn llama_sampler_init_min_p(p: f32, min_keep: usize) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details Locally Typical Sampling implementation described in the paper https://arxiv.org/abs/2202.00666."]
    pub fn llama_sampler_init_typical(p: f32, min_keep: usize) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " #details Updates the logits l_i` = l_i/t. When t <= 0.0f, the maximum logit is kept at it's original value, the rest are set to -inf"]
    pub fn llama_sampler_init_temp(t: f32) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details Dynamic temperature implementation (a.k.a. entropy) described in the paper https://arxiv.org/abs/2309.02772."]
    pub fn llama_sampler_init_temp_ext(t: f32, delta: f32, exponent: f32) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details XTC sampler as described in https://github.com/oobabooga/text-generation-webui/pull/6335"]
    pub fn llama_sampler_init_xtc(p: f32, t: f32, min_keep: usize, seed: u32)
        -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details Top n sigma sampling as described in academic paper \"Top-n: Not All Logits Are You Need\" https://arxiv.org/pdf/2411.07641"]
    pub fn llama_sampler_init_top_n_sigma(n: f32) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details Mirostat 1.0 algorithm described in the paper https://arxiv.org/abs/2007.14966. Uses tokens instead of words.\n @param candidates A vector of `llama_token_data` containing the candidate tokens, their probabilities (p), and log-odds (logit) for the current position in the generated text.\n @param tau  The target cross-entropy (or surprise) value you want to achieve for the generated text. A higher value corresponds to more surprising or less predictable text, while a lower value corresponds to less surprising or more predictable text.\n @param eta The learning rate used to update `mu` based on the error between the target and observed surprisal of the sampled word. A larger learning rate will cause `mu` to be updated more quickly, while a smaller learning rate will result in slower updates.\n @param m The number of tokens considered in the estimation of `s_hat`. This is an arbitrary value that is used to calculate `s_hat`, which in turn helps to calculate the value of `k`. In the paper, they use `m = 100`, but you can experiment with different values to see how it affects the performance of the algorithm.\n @param mu Maximum cross-entropy. This value is initialized to be twice the target cross-entropy (`2 * tau`) and is updated in the algorithm based on the error between the target and observed surprisal."]
    pub fn llama_sampler_init_mirostat(
        n_vocab: i32,
        seed: u32,
        tau: f32,
        eta: f32,
        m: i32,
    ) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details Mirostat 2.0 algorithm described in the paper https://arxiv.org/abs/2007.14966. Uses tokens instead of words.\n @param candidates A vector of `llama_token_data` containing the candidate tokens, their probabilities (p), and log-odds (logit) for the current position in the generated text.\n @param tau  The target cross-entropy (or surprise) value you want to achieve for the generated text. A higher value corresponds to more surprising or less predictable text, while a lower value corresponds to less surprising or more predictable text.\n @param eta The learning rate used to update `mu` based on the error between the target and observed surprisal of the sampled word. A larger learning rate will cause `mu` to be updated more quickly, while a smaller learning rate will result in slower updates.\n @param mu Maximum cross-entropy. This value is initialized to be twice the target cross-entropy (`2 * tau`) and is updated in the algorithm based on the error between the target and observed surprisal."]
    pub fn llama_sampler_init_mirostat_v2(seed: u32, tau: f32, eta: f32) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details Intializes a GBNF grammar, see grammars/README.md for details.\n @param vocab The vocabulary that this grammar will be used with.\n @param grammar_str The production rules for the grammar, encoded as a string. Returns an empty grammar if empty. Returns NULL if parsing of grammar_str fails.\n @param grammar_root The name of the start symbol for the grammar."]
    pub fn llama_sampler_init_grammar(
        vocab: *const llama_vocab,
        grammar_str: *const ::std::os::raw::c_char,
        grammar_root: *const ::std::os::raw::c_char,
    ) -> *mut llama_sampler;
}
extern "C" {
    pub fn llama_sampler_init_grammar_lazy(
        vocab: *const llama_vocab,
        grammar_str: *const ::std::os::raw::c_char,
        grammar_root: *const ::std::os::raw::c_char,
        trigger_words: *mut *const ::std::os::raw::c_char,
        num_trigger_words: usize,
        trigger_tokens: *const llama_token,
        num_trigger_tokens: usize,
    ) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " @details Lazy grammar sampler, introduced in https://github.com/ggml-org/llama.cpp/pull/9639\n @param trigger_patterns A list of patterns that will trigger the grammar sampler. Pattern will be matched from the start of the generation output, and grammar sampler will be fed content starting from its first match group.\n @param trigger_tokens A list of tokens that will trigger the grammar sampler. Grammar sampler will be fed content starting from the trigger token included."]
    pub fn llama_sampler_init_grammar_lazy_patterns(
        vocab: *const llama_vocab,
        grammar_str: *const ::std::os::raw::c_char,
        grammar_root: *const ::std::os::raw::c_char,
        trigger_patterns: *mut *const ::std::os::raw::c_char,
        num_trigger_patterns: usize,
        trigger_tokens: *const llama_token,
        num_trigger_tokens: usize,
    ) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " NOTE: Avoid using on the full vocabulary as searching for repeated tokens can become slow. For example, apply top-k or top-p sampling first."]
    pub fn llama_sampler_init_penalties(
        penalty_last_n: i32,
        penalty_repeat: f32,
        penalty_freq: f32,
        penalty_present: f32,
    ) -> *mut llama_sampler;
}
extern "C" {
    #[doc = "  @details DRY sampler, designed by p-e-w, as described in: https://github.com/oobabooga/text-generation-webui/pull/5677, porting Koboldcpp implementation authored by pi6am: https://github.com/LostRuins/koboldcpp/pull/982"]
    pub fn llama_sampler_init_dry(
        vocab: *const llama_vocab,
        n_ctx_train: i32,
        dry_multiplier: f32,
        dry_base: f32,
        dry_allowed_length: i32,
        dry_penalty_last_n: i32,
        seq_breakers: *mut *const ::std::os::raw::c_char,
        num_breakers: usize,
    ) -> *mut llama_sampler;
}
extern "C" {
    #[doc = " adaptive-p: select tokens near a configurable target probability over time.\n\n the adaptive-p sampler transforms the token probability distribution to favor tokens\n that fall near a user-configurable probability target.\n\n internally, the sampler maintains an exponential moving average of the *ORIGINAL*\n probabilities of selected tokens at each sampling step. it uses this EMA to compute an\n adapted target probability at each sampling step, thus maintaining the desired target\n probability over time.\n\n adaptive-p selects a token ID rather than just mutating candidates, so it must be last\n in the sampler chain (like mirostat, dist, greedy).\n\n only mild truncation before this sampler is recommended. we suggest applying min-p\n before adaptive-p as the only other active sampler in the chain.\n\n @param target select tokens near this probability (valid range 0.0 to 1.0; negative = disabled)\n @param decay  EMA decay for adaptation; history  1/(1-decay) tokens (valid range 0.0 - 0.99)\n @param seed   RNG seed\n\n ref: https://github.com/ggml-org/llama.cpp/pull/17927\n"]
    pub fn llama_sampler_init_adaptive_p(target: f32, decay: f32, seed: u32) -> *mut llama_sampler;
}
extern "C" {
    pub fn llama_sampler_init_logit_bias(
        n_vocab: i32,
        n_logit_bias: i32,
        logit_bias: *const llama_logit_bias,
    ) -> *mut llama_sampler;
}
extern "C" {
    pub fn llama_sampler_init_infill(vocab: *const llama_vocab) -> *mut llama_sampler;
}
extern "C" {
    pub fn llama_sampler_get_seed(smpl: *const llama_sampler) -> u32;
}
extern "C" {
    pub fn llama_sampler_sample(
        smpl: *mut llama_sampler,
        ctx: *mut llama_context,
        idx: i32,
    ) -> llama_token;
}
extern "C" {
    #[doc = " @details Build a split GGUF final path for this chunk.\n          llama_split_path(split_path, sizeof(split_path), \"/models/ggml-model-q4_0\", 2, 4) => split_path = \"/models/ggml-model-q4_0-00002-of-00004.gguf\""]
    pub fn llama_split_path(
        split_path: *mut ::std::os::raw::c_char,
        maxlen: usize,
        path_prefix: *const ::std::os::raw::c_char,
        split_no: ::std::os::raw::c_int,
        split_count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @details Extract the path prefix from the split_path if and only if the split_no and split_count match.\n          llama_split_prefix(split_prefix, 64, \"/models/ggml-model-q4_0-00002-of-00004.gguf\", 2, 4) => split_prefix = \"/models/ggml-model-q4_0\""]
    pub fn llama_split_prefix(
        split_prefix: *mut ::std::os::raw::c_char,
        maxlen: usize,
        split_path: *const ::std::os::raw::c_char,
        split_no: ::std::os::raw::c_int,
        split_count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn llama_print_system_info() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn llama_log_get(
        log_callback: *mut ggml_log_callback,
        user_data: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn llama_log_set(log_callback: ggml_log_callback, user_data: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_perf_context_data {
    pub t_start_ms: f64,
    pub t_load_ms: f64,
    pub t_p_eval_ms: f64,
    pub t_eval_ms: f64,
    pub n_p_eval: i32,
    pub n_eval: i32,
    pub n_reused: i32,
}
#[test]
fn bindgen_test_layout_llama_perf_context_data() {
    const UNINIT: ::std::mem::MaybeUninit<llama_perf_context_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_perf_context_data>(),
        48usize,
        concat!("Size of: ", stringify!(llama_perf_context_data))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_perf_context_data>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_perf_context_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_start_ms) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_perf_context_data),
            "::",
            stringify!(t_start_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_load_ms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_perf_context_data),
            "::",
            stringify!(t_load_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_p_eval_ms) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_perf_context_data),
            "::",
            stringify!(t_p_eval_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_eval_ms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_perf_context_data),
            "::",
            stringify!(t_eval_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_p_eval) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_perf_context_data),
            "::",
            stringify!(n_p_eval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_eval) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_perf_context_data),
            "::",
            stringify!(n_eval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_reused) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_perf_context_data),
            "::",
            stringify!(n_reused)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_perf_sampler_data {
    pub t_sample_ms: f64,
    pub n_sample: i32,
}
#[test]
fn bindgen_test_layout_llama_perf_sampler_data() {
    const UNINIT: ::std::mem::MaybeUninit<llama_perf_sampler_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_perf_sampler_data>(),
        16usize,
        concat!("Size of: ", stringify!(llama_perf_sampler_data))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_perf_sampler_data>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_perf_sampler_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_sample_ms) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_perf_sampler_data),
            "::",
            stringify!(t_sample_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_sample) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_perf_sampler_data),
            "::",
            stringify!(n_sample)
        )
    );
}
extern "C" {
    pub fn llama_perf_context(ctx: *const llama_context) -> llama_perf_context_data;
}
extern "C" {
    pub fn llama_perf_context_print(ctx: *const llama_context);
}
extern "C" {
    pub fn llama_perf_context_reset(ctx: *mut llama_context);
}
extern "C" {
    pub fn llama_perf_sampler(chain: *const llama_sampler) -> llama_perf_sampler_data;
}
extern "C" {
    pub fn llama_perf_sampler_print(chain: *const llama_sampler);
}
extern "C" {
    pub fn llama_perf_sampler_reset(chain: *mut llama_sampler);
}
extern "C" {
    pub fn llama_memory_breakdown_print(ctx: *const llama_context);
}
pub type llama_opt_param_filter = ::std::option::Option<
    unsafe extern "C" fn(tensor: *const ggml_tensor, userdata: *mut ::std::os::raw::c_void) -> bool,
>;
extern "C" {
    pub fn llama_opt_param_filter_all(
        tensor: *const ggml_tensor,
        userdata: *mut ::std::os::raw::c_void,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llama_opt_params {
    pub n_ctx_train: u32,
    pub param_filter: llama_opt_param_filter,
    pub param_filter_ud: *mut ::std::os::raw::c_void,
    pub get_opt_pars: ggml_opt_get_optimizer_params,
    pub get_opt_pars_ud: *mut ::std::os::raw::c_void,
    pub optimizer_type: ggml_opt_optimizer_type,
}
#[test]
fn bindgen_test_layout_llama_opt_params() {
    const UNINIT: ::std::mem::MaybeUninit<llama_opt_params> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llama_opt_params>(),
        48usize,
        concat!("Size of: ", stringify!(llama_opt_params))
    );
    assert_eq!(
        ::std::mem::align_of::<llama_opt_params>(),
        8usize,
        concat!("Alignment of ", stringify!(llama_opt_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_ctx_train) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_opt_params),
            "::",
            stringify!(n_ctx_train)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).param_filter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_opt_params),
            "::",
            stringify!(param_filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).param_filter_ud) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_opt_params),
            "::",
            stringify!(param_filter_ud)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_opt_pars) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_opt_params),
            "::",
            stringify!(get_opt_pars)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_opt_pars_ud) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_opt_params),
            "::",
            stringify!(get_opt_pars_ud)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optimizer_type) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llama_opt_params),
            "::",
            stringify!(optimizer_type)
        )
    );
}
extern "C" {
    pub fn llama_opt_init(
        lctx: *mut llama_context,
        model: *mut llama_model,
        lopt_params: llama_opt_params,
    );
}
extern "C" {
    pub fn llama_opt_epoch(
        lctx: *mut llama_context,
        dataset: ggml_opt_dataset_t,
        result_train: ggml_opt_result_t,
        result_eval: ggml_opt_result_t,
        idata_split: i64,
        callback_train: ggml_opt_epoch_callback,
        callback_eval: ggml_opt_epoch_callback,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ggml_backend_buffer {
    pub _address: u8,
}
